
* split out layout engines
  + using hooks

* losing a bit of the image
  + shows up as mc yellow border missing
  + also pink highlighter gets lost on bottom/right edges

* directories in the middle of a set of images
  + breaks next image on to new major (row/column)
    + so following image ends up at 100% minor axis
  + could just push all sub-folders to the end
    + consistent with OS behaviours

* start with pc, but set cell sizes using px after that
  + otherwise we get very strange effects during resize (at high seq)

* cold load seq=high jumps in Chrome only
  + something to do with the final stage
    + from container offset to scroll
  + there's a difference in the cell widths between hash->setScroll and scrollHandler
    + I suspect
      + we're collapsing it somehow
      + or chrome is collapsing it
    + verify by
      + checking fiddle
        + doesn't seem to happen
      + jquery checking the cell widths
        + seem fine
      + F10ing through things it does in between

* little bit of fun working on optimisation
  + reducing js load
    + Chrome profiling is most accurate

* eventually capture -8px margin on #sfun
  + before changing it to realign major
    + so that when we apply new value (to realign the major axis)
    + it includes the -8px
      + otherwise we show a little edge
  + not sure if this is necessary or not

* re-enabling buffering doesn't work
  + it doesn't load any images

* need to wait until there are no scroll events before realigning
  + otherwise scrollbar goes all over the place
  + could search the eventQueue for any other scroll: events
    + could flag each event as started
  + does buffering solve it?
    + means that repeat calls get ignored
      + not sure
      + worth investigating first

* scrolling backwards beyond visnear
  + jumps forward to show selected
    = try just buffering

* rewrite test logic, just document here
    + cold load 0
    + cold load low seq
    + cold load high seq
    + load 0 skip low
    + load low skip high
    + load high skip low

* jumping to seq creates different results to reloading to seq
  + like before, seq gets kicked right by preseq images loading

* offseq breaks preseq fix

* re-enable scroll buffering

* staged scroll should go row-by-row or column-by-column
  + also centre using offseq=centre
    + a number should preserve the number of scroll
      + but centre is more meaningful

* page up/down needs to work on viewport pages
  + can't rely on jumping a certain number of images forward/back
    + because they could be really narrow

* use offseq to maintain the relative position of the current seq image
  + fun to watch it grow and shrink

* sfun button needs to go into the corner
  + been pushed out by some padding/margin

* end event is resolving slowly
  + only after 10s expiry
  + it's getting lost during a scroll update
    + we know because it's a scroll:x=1799 event that expires
      + which triggers the original keyPress to resolve
  + the disconnect seems to be happening
    + because we try and scroll to 1799
    + but the scrollEvent that comes back is only to 720
      + could solve by estimating position of window near END
      + better to solve with wildcards
    + need to create an eventContext really early
      + at the point where we fire_keyPress(key_END)
      + that eventContext needs to be passed all the way through
      + and contain a wildcard
        + to connect with ambiguous scroll-to-end
        + now that's actually quite hard
          + the event changes nature with each pass of the batton
          + we're basically saying
            + when you fire a scrollUpdate for this,
              + call it something else
            + that's not an easy narrative
    + alternative is to soften the link between all fired scroll events
      + and the handlers that immediately follow them
    + or some combination of the two
      + something in the master eventContext
        + that says soften the following
          + temp issue: not timing out old events
    + alternative might be to try and more accurately guess
      + where scroll event will actually go to
        + i.e. document end - screen width
      + could do that as a simple max on the fire_scrollUpdate
        + that's pretty close
          + still having to expiry it though
            + let's look at context id to see which contexts are missing
      + it's clear that one of the images isn't resolving
        + when I force the deferred to resolve, everything is fine
--o--
* wire in deferreds through everything else
  + make it work for handler_hash first
--o--
* extend test suite
  + test reres
    + end
  + need to connect the deferred in the hash handler to some kind of external/api
    + pushing a value in the URL might be an option
      + but that only extends to hash values
      + nice to come up with something global
        + need to find a way to push identifiers through the event chain
          + e.g. x in scrollUpdate(x) -> handler_scrolled(x)
--o--
* end test has errors
  + some images have been reloaded
    + it's because we're resolving the scroll event after the metadata has been returned
      - not after the reres has completed
    + I can see cases where we might want both of those
      + but for now, concentrate on the images loading

* forward scroll newbies
  + newly visible images are coming into view too far apart
    + better to assume a narrower cell width then correct it
    + take an average major
      + maintain everytime we shrink a cell

* directories as full cell multi-image panes
  + basically like little microcosms of the whole screen
    + play with a border to make them look different

* selector doesn't show on two sides
  + need to show all the way around the selected image

* extend test suite once all current tests are working
  + test reres
    + mouse wheel two images right
  + test imgmetric vis

* visTable bugs
  + fairly minor stuff I think
    + use test suite to debug

* .s in directory names, like mq

* mousewheel after scroll needs to re-align
  + otherwise can be scrolling in half-images

* sfun icon
  + think about the glassbar concept
    + pushing out from the icon

* shiny menu bar

* need to get an alpha online
  + doesn't need to be a big release, but it does have to be a first release

--- first launch: it's not a big deal ---

* FEATURE: video

* FEATURE: show semi-opaque numbers in circles over each image on a direction change
    + to reflect order of images

* instead of requesting metadata
  + could just request an image of the size we want
    + (guess that it might be available)
    + and display whatever comes back
      + then request metadata asynchronously
        + and probably for everything rather than just the visibles

* thinking about maximising the space
  + could swap an image +/-1 to get it to the top of a column
  + landscape
    + could expand the width of a cell
    + could decrease the height of a cell
  + portrait
    + could expand the height of a cell
    + could decrease the width of a cell

* imgmetric as mini bar chart
  + show percentage in background too
    + visually reinforce when you're looking at massive images (small)

* page up/down should advance to next image that partially off screen

* vertical mode needs work
  + catch up js with horizontal
    + should work properly in test suite too

* show video entries in directory thumbnails

* show imgmetric on videos

* single entry in folder
  + or fewer entries that a single column
  + align left, not centre
    + which will mean it doesn't matter if we turn off border-left

* never show thumbnails on mediacache

* shuffle directories to top
  + like in windows

* introduce HTML for markers
  + directories/images/files
  + but don't worry too much about what markers we insert to start with

* shuffle non-image files to bottom
  + just for convenience

* test using app.php for everything
  + is it possible to make elan an exception (and use app_dev.php)

* think about javascript changing cell percentage based on mean row height/column width
  + alternative is dynamically reducing column cell widths, column by column
    + alternative is better I think

* cookie header options
  + to remember what we were looking at
  + think about hash-bang/url change too

* safari sometimes-sometimes-not resizing images
  + see iPad

* folders maintain square aspect in landscape cells
  + make x-bound
    + write javascript to detect div.folder width and flip class
    + write y-bound class specifically for div.folder

* Redraw folders at 1440x1080
  + 4:3

* Add ../ up arrow to directory listings
* create file icon

* Nice looking header icon (sf in circle with chunk bitten out)
* Rotate header icon on rollover header expand

* Horizontal/verical icon
* Light/dark icon

* snameed jQueryUI scroller for number of images wide/high

* make imagemeta returned JSON take IIIF Image API format

* Fail nicely when a file/directory/path element doesn't exist

* Using Project sheet in Google drive for major functional items
https://docs.google.com/a/lightenna.com/spreadsheet/ccc?key=0AuXNj3kHNsfddFhwTGZpcERMd1JweTVuMEFoS3h6YUE&usp=drive_web#gid=0










































Done
----

* setup paths bin

* install composer

* use composer to install symfony2

# install composer into bin directory using downloaded install script
php bin\install-composer.php --install-dir bin

* create a project
php -c conf bin\composer.phar create-project symfony/framework-standard-edition ./vendor/symfony2/ 

* commit everything to an open repo

* test basic route on prod

* create directory indexer like before
  + but under symfony

* setup php-dev server for dev if caching is annoying
  = didn't have to, configured normal apache to use app-dev

* setup model for record(directoryEntry)

* setup controller and route

* setup directory, file and record->directory->zip

* never add trailing / to directories
  + and make thumbnail paths work using linkpath

* Double data/ for directories with trailing /
  + http://localhost:8080/file/data/

* Images not showing from zips

* Error image

* no route found for /file

* double // for /file/ or /file

* 404 for for / or <blank>

* write test function for jazzy new performFilenameSubstitution()
  + extend to cover zips

* clipping bug when used *with* resize
  + suspect it's to do with not resetting width and height
    + better to re-read

* Write tests for image resize/clip

* Internal server error on really big image requests
  + if requested size is greater than image, just return image
  + http://sfun.elan/image/data/alice%20eve.zip/alice%20eve/alice-eve-06.jpg~args&thumb=true&maxwidth=4250

* Add FileReader, then MetadataFileReader, then CachingMetadataFileReader
  + but only after we've made the current read work
    + unless we're refactoring in the wrong direction

* Make test suite work for ViewController URL transformations plus new FileReader ones
  + sort of, ok for now

* Rewrite ViewController to use FileReader

* Make Fileview work using FileReader family classes

* Try getListing on single file
  + should just return that file

* Fix zip_part being given all the args

* Make Imageview work using FileReader family

* Weed out old tests

* Deprecate old ViewController code as using FileReader instead

* Double appending filename to end of video in stats->file

* Get cache working for video

* Need to make mediacache directory for -linux install and enable for selinux

* ../ bug in splitFilePath

* write more tests for FileReader
  + crop child as well as crop parent within zip
  + e.g. http://sfun.elan/file/data/alice%20eve.zip/ is wrong

* add super-short video to test suite

* handle large images sanely

* add test to check that two different timecodes produce two different frames
  + and same timecode produces identical frame

* fix missing video thumbnails
  + it's SELinux

* add support for .png
  + process png as png, not jpeg

* mfr bug for test suite
  + whenever we open a zip
    + stats->file is the zip folder name
    + stats->name is the file name

* Nested folders in zips should be links
  + then think about collapsing

* factor out CacheHelper

* Reading all the files for resolution/shape is too slow
  + introduce caching by default

* Javascript resolution check and class apply
  + x-bound and y-bound
    + have temporarily disabled cache to apply this
logic check
cr/ir
portrait container 200x300 ratio = 2/3 = 0.66
wide image = 300x200 ratio = 3/2 = 1.5
bound, 0.66/1.5 = 0.4 = <=1 = x

portrait image = 200x300 ratio = 2/3 = 0.66
bound, 0.66/0.66 = 1.0 = <=1 = x

v-portrait container 150x300 ratio = 1.5/3 = 0.5
bound, 0.66/0.5 = 1.33 = >1 = y

v-wide container 400x200 ratio = 4/2 = 2.0
wide image = 300x200 ratio = 3/2 = 1.33
bound, 2.0/1.33 = 1.66 = >1 = y

square image = 200x200 ratio = 2/2 = 1.0
bound, 2.0/1.0 = 2.0 = >1 = y

portrait image = 100x200 ratio = 0.5
bound, 2.0/0.5 = 4.0 = >1 = y

* not 100% on mini-pictures in folder
  + probably 20%

* folder image and overlay
  + small image alignment

* 100% height on directory background
  + if that's possible

* send out transparent gif/png for missing previews

* strange thumbnail zooming thing
  + thumbnails getting big and blurry
    + because the point we store back to the cache is after cropping
    + change mfr->cache() call point or add clipwidth/height to cache keys

* every page is too high
  + being given a redundant vertical scollbar
    + try making Symfony use production version

* image vertical centering

* back to directory view doesn't bound images properly
-- same as --
* javascript image classes failing
  + works on refresh, but not always on first load
    + disable caching to debug
      + doesn't happen reliably, needs more investigation

* javascript re-assess x-bound or y-bound on resize

* tweak sfac on js y->x scrolling

* set screen-x/y as percennamee
  + covers pre-update scenario to fix quirky drags
* check chrome re-bound

* mac dragging around the edge messes up sideways scroll
  = solved by stopping bubble

* Either move $this->stats down to MetadataFileReader
  + or rename as AwareFileReader
  = refactored, much neater now

* Convert args to object

* Don't cache error img
  + test suite failing because error image comparison fails

* Repeated vertical (flow-y) resize toggles between rows
  + slightly funny stuff going on
    + jitters between 2 and 3 rows
    ? could be finding a % in the id because we set one?
  + test drag behaviours
  = not perfect, but good enough

* Windows test suite errors

* Re-do folder from ai to produce authoritative psd
  = not psd, but exported from ai

* Debug image
  + turns out to be a artefact of an image -> in a zip -> in a shared folder
    + equally only applies to thumbnails (which is very strange)

* Create a test share and mount it into the structured tests directory
  + that way it should never affect users
    + and can provide that

* Folders on dark background

* Folders (part 1) maintain square aspect in landscape cells
  + fix positioning

* Fix nasty selection bug
  = test, done I think

* Producing two cache entries for a single image
  + don't save to cache if this image was loaded from the cache
    + ah ha, might be already protected for that
    - mmm, not
  = fixed by ensuring that we don't always generate a new cache key
    + which isn't necessary when rewriting from the cache

* Cachekey not set for directory listing
  + except first entry
  + cache is being used for all the images
    + but for some reason their cachekey isn't making it into the directory listing
    + that may not be a problem, but worth investigating
  + this is true for both zips and normal directory listings
    + it means we're not finding cached entries
      + which in turn means we never fetch metadata for dir entries
  + actually weren't putting any cachekeys in
    + trick is to use the right cache key
      + always the one for the file in situ, not in the cache
  + right, now we're getting different cachekeys because
    1. actually image is a restricted thumbnail, so uses args
    2. is just an image path, so has no args
    + verify that's true

* Clean up metadata that gets stored in cache files
  + don't need all the spurious stuff
  + rewrite names
    + width_original
    + height_original

* Think of a way to store data-native-width and data-native-height in the cached image metadata
  + worth finding ways to store and retreive image metadata anyway
    + plus it enables re-res
  + start with cache function
    + write in native-width/height
* Use cached data to write native width/height into data fields

* Round newwidth/height

* Fix test suite errors

* write getFilename and getFullname tests for test suite
  + important to have a record somewhere of what these functions should return

* video thumbnails need metadata too

* bug
probably caused by
http://sfun.elan/image/data/alice%20eve.zip/alice%20eve/alice-eve-jiggle-ibbZy7SI8fCxXB.gif~args&thumb=true&maxlongest=200&
http://sfun.elan/file/data/alice%20eve.zip/alice%20eve/
getimagesize(): Read error! in /var/www/git/github.com/structuredfun-linux/structured/htdocs/src/Lightenna/StructuredBundle/DependencyInjection/CachedMetadataFileReader.php on line 194 
+ cache is producing bad gif
  + need to make it produce a gif, but a wrapped jpg

* test out showing display-size in imgmetric in js
  + then come back to html

* get relative position of image within parent container
  + then apply to imgmetric
    + parent container is shared parent of both img and imgmetric
  = did using absolute coords
    - relative (using jquery.position() instead of offset) doesn't put it anywhere close

* bug: imagemeta is requested for each image twice
  + look at Firebug Net tab

* bug: imagemeta doesn't request images at right (bigger) size
  + got to sort of pass waitForLoad right through the chain

* use js to re-write all image URLs to local hashbangs
  + indirect via a handler rather than rewrite

* right-arrow, down-arrow
  + go one frame right

* click goes to flow-1
  + and jumps to that image

* firefox scaling factor
  + for scroll-x

* re-res directory thumbnails as per normal images
  = decided not to re-res for jq load
    + but have improved res to 200px

* title on folders

* get state in one place
  + URL: breadth, image seq, direction
    + fall back to HTML if not set
  + make nice functions that cascade
  ? do we want to cache in javascript?
    ? could this be a good time to embed a framework?

* back to page without explicit breadth
  + needs default

* clicking on an image pushes state
  + but it should only do that if the URL is different
  + otherwise the history queues up with duplicate entries
    + which makes 'back' confusing

* imageAdvance crashes browser

* need to detect if next/previous pushes us on to a new page
  + e.g. always for 1 up
  + only scrollTo() if advancing to new page

* scrollTo breaks click
  + advance to a high image
  + go fullscreen
  + advance a few more (to about 3rd or 4th)
  + go back to b2
    + think this is just like the upper end crop

* 1 minor bug in linux test suite
  + also just 1 (same 1) in windows

* reduce apache to 2 concurrent threads
  + should never use more than 2 cores
    + see if that helps with the responsiveness of the page
      - otherwise may need to use blank images
  + working for windows
    + not going to apply to linux config because we don't have the same whole-app

* time for a front-end test suite
  + introduce a basic QUnit
  + introduce a #test
    + as a new button for the header in its own file
  = half way through this
    + press on with mustache template

* return jumps back to previous image
  + but doesn't always go back to
  + seems to work ok
    + will revive if I can replicate again

* arrows get stuck sometimes
  + seems like history.js is playing up
    + get strange behaviour with advance (+/-) where it won't go one direction

* advance should wrap around

* after a click, need to focus on an element so we get keypresses
  + try jquery focus
    - it's not a focus
    + left and right arrows work, but return does not
    = just needed a preventDefault to stop the return triggering a URL refresh

* ctrl+home/ctrl+end

* scrolling needs to advance seq selection to the right image
  + important because we can't use page up/down or arrow keys after scrolling

* resize (refreshCells) event in Chrome
  + creating a new image and then measuring its width and height doesn't work
    + ix = iy = 0
  + solved by using an onload

* probably need to invest time in the javascript test suite
  + I keep exposing stuff that doesn't work on my non-test browser
    + once I've started it will flow
    = got something started

* only swap out visible images
  + swapping them all is too intensive
    + probably should try to avoid going over about 50 x 1000
      + add as line in config file
  + made progress on this
    + may return to it

* checkBound is now async
  + we need to do all the async stuff before trying to do the sync stuff
    + build a loaded image size map on image reload
    + build a cell size map on window resize
  + it's another level of complexity
    + it means we're partly reliant on the DOM, partly on js proxy objects
  + this is important
    + we need to get some kind of promise setup

* work on page load speed
  + currently reloading all images (from cache) on every checkImageBounds
    + solved using test

* first load (uncached) makes a mess of image bounds
  + it's because we've not got a loaded-width/height

* imgmetric scattered all over the page after switching from b=2 to b=1
  = ok for now
* current loading 250s en route to loading 500s
  + suspect it's to do with image bounds
  = ok for now

* extra scollbar, bit too much margin somewhere
  http://10.12.1.160:8097/file/data/alice%20eve.zip/alice%20eve/

* protect handler_scroll from itself
  - I think it's getting stuck searching for img.visible when there aren't any
* handler_scroll shouldn't be called when the page loads

* need to add scroll handler
  + at the moment we trap against mousewheel
    + but it's possible to drag the scrollbar

* setVisibleByScroll
  + tricky
    + can't quite decide if it should just scroll and
      + let the scroll handler sort out all the image
    + I think yes

* sort of moving everything out of init() now
  + and triggering hash change instead

* something is triggering a scroll event to 0,0
  + happens during page load
  + e.g. http://10.12.1.120:8097/file/structured/tests/data/20-image_folder/#breadth=2&seq=9
  + may not actually be resolvable
  = have inserted a jump-back using ignored scroll:0,0 event

* change out all the clicks to be hash changes
  = done most of them

* change image seq to entity seq
  + we want to be able to select folders
  + throws error on 
    + http://10.12.1.120:8097/file/playspace
  + because directory features in middle of images
  = not without issues but working pretty well

* change cache file extension into .dat
  + avoid mediacache leak

* test suite error
  + only occurs when running a second time
  + it's a cache error
  + need to keep hold of the original extension

* first load after cache clear
  + not reresing images
  + seems like we're not waiting for image load before firing imagemeta request

*** have set a cache clear every run! ***
  + but only from my local settings

* need to be able to merge in settings from config files

* could be double-loading the metadata
  + would explain why we're swapping out the images twice

* NaN% on certain images
  + there's an ordering of concurrent ops that allows this
  + problem is that the image is loaded
    - but the imagemeta call hasn't returned yet
    + so we're trying to compute %age based on width/height-native
    + but they don't exist yet
  = have protected
    + watch for images not re-resing

* double end doesn't work
  + seems to only be in larger datasets
    + this happens when we end up with no .visible entries
      + we do a select on a jqEnt that doesn't exist
        + protect against that
      + then fix the forward

* right arrow from sMAXb1
  + should wrap around to show s0b1
  - but get error

* Apache builds for Windows
  + http://www.apachelounge.com/download/additional/

* don't load all thumbnails in very large data sets
  + still quite slow on load
    + think js op is slow
  + also doesn't work
  + need to do it the lazy loading way
    + http://www.appelsiini.net/projects/lazyload
    + start by implementing noscript version
  = working, may need to do more

* dragging in very large image set
  - jumps back to zero every drag

* key press (like ctrl+end/home) triggers hash change
  + hash change loses key focus from window
    + need to preserve so we can 
  = seems to be working for now

* fullscreen from visible images
  + needs to refreshImage

* images not displaying
  + problem doesn't seem to be caused by the refactoring
  + the cells are slightly outside the window (top:-1, left:-1)

* move selectable, selected, visible up to cell
  + test thoroughly

* clean up isVis to make it reliable for on-screen

* fix end bug

* fix test suite
  + end doesn't select last entry
    + it's toggling between 838 and 836
    + which I think is caused by isVis getting it wrong
      + test using #!seq=8
    + do it properly with unit tests
      + tricky to test
    + best to do it with the test suite

* extend test suite
  + test visibility
    + scroll to start, scroll to end, scroll to middle
    + test all visibles in one block (no littering)

* extend test suite
  + test reres
    + reres of first x images

* need to work out how to handle tests keyed upon delayed events
  + deferred promises are the way
    - but passing them around is tricky
  + either parent thing can make a queue
    + and pass it to all the sub functions
  + or originate in each sub function
    + and then aggregate queues in parent functions
  = brilliant piece on deferred patterns
    http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt2-practical-use

* fullscreen of image 0 needs to hide all imgmetrics

* fullscreen/return should toggle
  + between b1 and bPrevious

* changing from b2 to b1
  + need to do another refreshCells at least on current image
    + because cell shape may have changed dramatically

* reload page from final entry doesn't swap out images properly
  + seems not to be loading thumbnails
    + so the 500 request doesn't get any metadata

* arrow-key / home after scroll

* pull forward UI test suite

* rewrite isVisible function to cope with partials
  + frequently images are partly on screen
    + but not treated as visible

* dropping back from fullscreen, checkImageRes swaps out all the images
  + not just the visible ones
    + this is all to do with async stuff
    + we need to wait for the hash updates to complete before doing a checkimg

* not loading right image just in time
  + in fullscreen mode
    + loading one image behind

* this test suite stuff is so important
  + I've just recovered from breaking it
    + a break that wouldn't have occurred if I had a reliable test suite
    + and could have been hunting for regressions all the time!

* re-write hashTable using Object.create
  + put in separate file for now
    + can aggregate later
  = thought better of
    + not enough instantiation to merit prototypes


* force imagemeta to return meta

* modify the numbEventQueue to be deferreds manager
    + that's a pretty good handler
    + needs a hash (string), done function pointer and parent
  + looking pretty good
    + need to find a way to pass deferreds through the eventQueue
      + will circle back to this once we've got deferred cascading through the actual event handlers
* expose deferred through exported API
  + need to create deferred first
    + then pass into following event handlers
  + so we can queue up dependent functions
    + like the test functions
  + we get into complications when we're trying to push a deferred through a hash update
    + there are potentially many layers
      + one hash update, triggers scroll update, triggers hash update
      + nice to great some kind of general rule
  + how about eventQueue for storing the deferred
    + create when eventQueue item created
    + pick it up in the handler
      + could even link up parent events
        + done when say setScrollPosition called indirectly by a handler
  + maybe it's a combination metaphor
    + we need eventQueue to bridge between code->handler
      + because it's async
    + how to do parenting
      + class-wide var is complicated because it could get messed up
        + it's analogous to the old-school global variable
      + passing deferred from function to function requires care
        + it's going to need elaborate lacing together
        + could pass event object around
  + making eventQueue fairly smart
    + tries to wrap up as much of the promise logic as possible
      + because then it's all in one place
        + if a 'parent' set it does get resolved once its child is resolved
  - beginning to wonder if the necessary deferred tree will be just too complicated
    + it reaches through almost everything
      + might need to rewrite most ops as synchronous
    + not sure
    + using the #hash is elegant
  + eventContext originators
    + fire_
  + eventContext decorators/ornaments
    + everything else
  + eventContext resolvers
    + terminals that create a local context and resolve
  + execution summary
    To numb a listener, at the point we decide to numb it
      eventQueue.pushChild(eventContext, { 'replaceEvent': function(){} })
    To pass a context on, which may have been numbed upstream
      eventContext
  + what about passing
    + everything we pass it into
      + needs to be able to pass it out?
  + check the event story
    + fire_scrollUpdate creates eventContext(1)
    + handler_scrolled receives eventContext(1)
      + calls refreshVisibility with same context(1)
        + refreshVisibility doesn't do anything async itself, so no forking
        + calls setVisibleAll with eventContext(1)
          + calls setVisibleImage with eventContext(1)
            + calls refreshImage with eventContext(1)
              + calls refreshBounds with eventContext(1)
                + calls getLoadedResolution with eventContext(1)
                  + creates it's own child eventContext(2) using pushChild
                    + sets up stuff to happen
                    + returns eventContext(2) so that parents can queue up other stuff for AFTER this happens
                    + when stuff happens the child resolves (eventContext(2) resolves)
                    + the things that the parent queued up start getting executed
                  + returns eventContext(2) if it scheduled stuff, or eventContext(1) if it didn't
                + refreshBounds then queues stuff against the eventContext it receives (2/1)
              + refreshImage then queues stuff against the eventContext it receives
  + remember
    + pushChild only when we're about to WAIT for something to happen (e.g. an actual async wait, e.g. image load)
    + .then to setup things to happen in sequence
    + can normally chain execution with .then()
      + only need to create a new context when
        + waiting on something unpredictable
        + OR MAYBE when doing multiple things
  - not sure about pushChild needing to 'resolve' the parent
    + think it's probably a yes
  - not sure about how to execute multiple things in sequence
  + not currently preserving eventContext across checkMetadata
    + that a bit is deliberately async-unsync
  + everything is stacking up on the eventQueue
    + seem to be resolving <unset:2> several times over
      + could be because 2 is everything's parent
  + problem is that we're stacking all the eventContexts in series
    + there are some that are event dependent
      + which means they can resolve at any time
        + which means the middle of the chain resolves
    + need to create contexts for each event-dependent event
      + then do some kind of aggregation to say 'wait for them all to finish'
    + eventContext:parent is used to kick the parent
    + eventContext:deps is used to store a list of all the contexts we depend on
      + everytime the parent gets kicked
        + it checks to see if all the deps have been satisfied
    + if there are no deps
      + it resolves right away
    + I get foggy on the different situations this can come up in
      1. do something in a child function, when it's done, allow its parent to be called
      2. ? is there a 2?

* add class nearvis
  + add to it 2x breadth on either side nearvis

* look over remaining eventContext vars

* need to expire unmatched scroll events
  + mouse wheel produces lots of scroll events
    + they hang around in the queue indefinitely
    + could expire after 1 second
      + because the gap between scroll and handler shouldn't be more than that

* think about buffering scroll events
  + handler_scroll
    buffer (function(){}, 50)
    + could return using a deferred
      + like a deferred, simple
        + but we have to be careful because 
          + there could be queued eventContexts interleaved with random scroll events
          + each one of those eventContexts needs to get dealt with
    + could return doing something clever with the invented context
      + could pushChild each context
        + so that once we complete the last one
        + we also complete all the others

* rebound/x-bound on 305 at fullscreen

* only show imgmetric when image has re-res'd

* smooth scrolling on trackpads
  + can't differentiate trackpad,
    + but can do smooth scrolling on variable
    + could make it an option

* synchronicity
  + waiting on all getImageMeta/metric pos to complete
    + before re-resing all
      + before updating
  + ideally want things to only aggregate at highest level
    + so that each thread can keep the pipefull
  + not important now

* refactor eventContext stuff
  + I'm not going to want to do it
    + but go back in, test alternatives and clean-up eventContext stuff
    + there are too many unanswered questions
      + and I'm sure I can make the syntax easier
  + started already
    + straight deferreds are the way to go
      + maybe just use eventQueue to handle the link between fire_ and handler_
  + question: how do we handle events we're trying to nullify
    + search 'replaceEvent'
      + refreshSelected / imageAdvanceTo 
  + question: should we sometimes resolve deferreds only after the handler fires?
    + like
      + fire_scrollUpdate
      + refreshSelected / imageAdvanceTo 
    + risky?
      + maybe
  + some contexts contain deferreds that are getting resolved
    + but the eventContext never gets removed from the eventQueue
      + while it's there it could potentially interfere with other queued eventContexts
      + need to remove them
        + try and use the eventQueue to resolve
          + because then the resolve can also remove from the queue
        + that requires that events can identify themselves to the queue
          + and say 'delete me'
        + best place to handle that is in hashTable
          + which means moving evid (eventQueue) to id (hashTable)
  + unfilled get requests are fine most of the time
    + they don't accumulate which is great
  + having some issues getting events to resolve all the way down the chain
    + try from api_ call and work backwards
      + carry on with this!
    + it is resolving, but only after 10s expiries

* optimise dragging in large image sets
  + implement vistable
  = it's very fast now

* refresh vistable on breadth/direction change

* viewing images fullscreen broken
  + suspect it's related to refreshing vistable
    + some work ok,
    - but not seq=0 or seq=1
  + no images are flagged as visible

* vis missing one image
  + /file/structured/tests/data/20-image_folder/#!seq=9
  + it's because we're hitting minref = maxref = ref 5
    + when ref 4 has the same value
      + need to always work backwards to be sure
    + needed a work forwards (like work backwards)

* nearvis isn't always right
  + in small image sets
    + good in large sets
  + need to remove nearvis
    + or rather rename nearvis once it's no longer near
  + better, but still too much nearvis in image_folder dataset

* too many visibles
  + seq=0 showing 8 & 9
    + should stop at 7
  + fixed with rounding = 3

* can scroll selected image off-screen
  + updates hash but doesn't update selected

* end, fullscreen, home
  + check re-res

* page up should eventually move the selection to 0
  + page down should eventually move to end

* imagemeta/ endpoint should always get image metadata
  + at the moment it only produces good metadata for pre-cached images
    + if we discover an image uncached
      + we should cache it at standard thumbnail size (longest edge 200)
        + most cache requests comes in 

* treat direction as another piece of hash state
  + where a hash value is the same as
    + NOT what's in document 
      + because it changes
    + the default value from the last page load

* res change needs to fresh metric positions
  + could tie that into refreshCells

* accelerate scroll catch-up
  + working but needs to be quicker
  + may need new async/promise trick

* home/end stalling
  + need to protect fire_hashUpdate
    + when firing will never trigger the handler_
      + i.e. home when at seq=0, end when at seq=last

* thinking about splitting the metadata store off from the mediacache
  + it's not without its complexities
  + the problem arises because we cache an image like thumbnail?maxlongest=200
    + I think it's reasonable to ask for image metadata for the same size
  + have found a workable solution for now
    = will delay decision for now

* border 4px on .cell a
  + once alignment is working

* cell resizing complexity
  + normalise heights at current width
    + work out proportion
      + that is the height at the point where this image becomes x-bound
    + trim the waste
      + leaves waste top and bottom
    + need a width which 
* need to refresh visTable only cellRefresh done

* introduce (!reloaded-width) data-ratio
  + updated everytime we load an image
    + loaded width is only updated the first time
  + addresses basic wobbles
--o--
* cells jigging about
  + gonna try not updated loaded-width
    = introduced ratio which stabilised them

* scrolling through directory is jumpy

* refreshCells is tricky
  + we really want to do it once
    + but at the moment we refresh each image (refreshImage)
      + and within that refresh its bounds
    + we need all the bounds back
      + to get the imageContainer sizes
        + to work out the free space around each
          + to average across a row/column
            + to resize the cells
              +++ to set the new cell sizes
                + to read back the new sizes
                  +++ to request the new resolutions
    + can't check bounds until all the images (thumbnails) have loaded
    + we will work through the images in order
      + but they'll load out of order
        + so we're going to struggle to get the rows
      + could break refreshImages into two phases

* need to wait for nearvis to be loaded
  + before trying to resize their cells
    + thinking about coupling all cellResizing to image loading
      + as soon as thumb loaded, it stays loaded
      + thumb loading
        + stores loaded-width
        + triggers attempt to resize cell
    + thinking about these things in cell singles/pairs/quads/octs
      + known as minorGroups
      + every load event checks its minorGroup
        + e.g. column for x-major, row for y-major
    + means that we're not formally doing a cellresize on all visibles any more
      + instead we do a resize on a single/pair/quad/oct because it becomes visible
  + this takes us back to hashTables
    + ideally want to preserve bucket information in visTable
      + and be able to update singles/pair/quad/oct (SPQO) easily
        + without having to rescan the whole lot
  + currently the whole vis chain works to a single set of functions
    + making this easier to change
  + however the resize event is important here
    + when we resize at 0
      + everything works beautifully
        + because there's no width change in anything prior (off-screen left)
    + when we resize at 500
      + everything jigs about horribly
    + we're trying to get to the point where
      1. resize @0 works
      2. scroll backwards and forwards works
      3. resize @500 works
    + that leads me to think
      + never change the width of an off-screen element prior (left or up)
        + that includes nearvis
      + probably keep processing cellresize in large batches of visible images
      + if we do have to adjust a prior cell width/height
        + always tweak scroll position to compensate
          + that's probably tricky to do surruptitiously
      + don't strip all previous width/heights
        + except on repaint event
          + and even then I'm not sure about it
      + series of fixes might be the best way to counter it

* forward scroll nearvis
  + if we try to cellresize on a cell without a thumb yet
    + it probably won't have a ratio
      + which returns a NaN problem
  + insert a getLoadedResolution and break second part into callbackfi
    + could make cellResize resolve a deferred
      + could make refreshImageResolution dependent on it
      + in fact should do that
        + but may still process 'nearvis' as async
        + leave as async
      + can make something async in one thread
        + and resync in another
          + the image loading lifts all boats

* big picture goal
  1. resize @0 works
  2. scroll backwards and forwards works
  3. resize @500 works

* forward scroll nearvis
  + shrinking visibles brings new 'nearvis' into view
    + need to make them visibles too
  + part of the process needs to expand the 'vis' selection
    + that also means expanding the nearvis selection

* vertical scroll doesn't work nicely yet
  + it's something comparatively simple
    = * instead of /
      + affected by alignment bug as per horizontal

* alias .sfun as this.containerName

* cell sizes jigging around
  + high seq numbers do 2 draws
    + first looks pretty good
      - but 2nd is weird
    + it's not the reresing
    + it's not resetting ratio
  = pretty sure it was a mixture of x-bound and y-bound

* changing breadth, direction, viewport size
  + needs to clear cell-specific percentages
    + then re-apply them

* even up border all the way around
  + actually important to cue which way the there's more content
  + margin-top: -8px lifts everything up
    + almost there, but we're not quite
    + right hand edge doesn't get thing
  + horizontal
    + need border on right hand edge
  + vertical
    + need border on bottom
  = don't worry about it for now
    + will have to insert an additional element

* chase down the NaNs
  + they're a lead
  + good debugging url mb@seq=288
    + debugging is hard
    + it's to do with an out-of-order execution (OOOE)
      + stepping through in a debugger doesn't find it

* perc's are not showing
  + but only for the latest batch of loads
    + old (but still visible) images lose their perc
    + it's because they're being left in a 'reresing' state

* introduce idea of partial visibility
  + sometimes we want the test to include 'partials'
    + e.g. 'visibles'
  + sometimes not
  + suggest we introduce 'partial'
    + rename nearvis as visnear
    + introduce vispart
    = it is now possible for there to be no 'visible' images
      + only vispart, but that's ok

* split structured.css from structuredfun.css

* reload on page with #!seq=0 (or just #!)
  - doesn't load images
    + seems to only load images if seq > 0

* reload on page with #!seq=0 (or just #!)
  - jumps to seq 5
  + even on mas it's doing to same thing (0->2)

* can't select seq for vispart
  + i.e. seq > visible

* vispart doesn't work on first two images

* jump straight to cell
  + e.g. seq=17
    + this is being killed by the scroll0,0 browser glitch
  + event order
    + handler_scrolled to #seq-17 (cells unresized)
    + handler_hashChanged seq=17
    + handler_scrolled to 0,0
    + handler_hashChanged seq=17 (doesn't see anything changed)
      + shouldn't do a refreshVisibility because we're looking at the wrong range
      + instead we need to make it realise seq has changed
        = done with a forceUpdate
  + at handler_scrolled to 0,0
    + need to default-out all the state
* a [breadth change] click seems to fire hash change seq=10
    + then fire hash change seq=10&breadth=1

* jump straight to cell for b1
  + e.g. breadth=1&seq=17
  = also fixed with forceUpdate

* high seq clicks (b2 to b1) jump back to seq 0
  + tricky
    + breadth change clears cell width/heights
      + which is good because we don't know where they're going to be
    + if we go to where seq 10 is now
      + the cellsResize will move it
        + so we end up seeing seq > 10
    + this also triggers hashChange trickle from seq=10 to seq=12
      + because 10 is only partly visible (vispart)
--o--
* can replicate exactly same issue
  + jump to high seq
    + then left arrow down through seqs
      + spacing whack
        + so we end up in the wrong place
  + need to work out exactly what's happening
    + because preseq images don't appear where I'd expect them
--o--
* develop a preseq spacer
  + as we're resizing cells to the left/above seq
    + insert a spacer at 0
      + then yank it out and move the scrollbar to compensate
  + a spacer may not work
    + because sometimes the preseqs are _wider_ than before
      + so we need a negative spacer
    + best done as a negative left/top on the ul.sfun
  = pretty good, bit of jitter but ok

* trigger redraw on offseq change

* scroll0,0 can arrive before or after scroll 32418
  + before is fine because it manually triggers handler_hashChanged again
  + after is a problem that means we render 0 instead of high seq
    + also the actually scroll to 0,0 can happen in the middle of our execution
  + need to capture the document scroll position at the same time as making the isVisible decision
    + not quite isvisible-time
  + seq106, 18851 + 839 = 19690
    = postponed, ordering not clear yet

* end key isn't returning at load completion
  + it's also jittering its way down from the last screen
  + seq 0 does now return properly

* nullify scroll0,0 not resolving at the time
  + it only gets cleaned up much later
    + can we resolve it as soon as it's nullified?
  + it's not that the nullified scroll0,0 event doesn't get resolved
    + it's that the nested handler_hashChanged event doesn't
  + there's an ordering issue
    + sometimes the scroll0,0 comes before
    + sometimes it comes after
  + this could be to do with the buffering of scroll events
    + we get a scroll0,0 and a real scroll very close together
    + try not buffering
      = have disabled buffering
  + parent (scroll0,0) is resolving before child (hash:seq208)
    + child effectively gets orphaned
      + but child is independent of parent
      + so it shouldn't matter
    + handler_hashChanged times out
      + profile every stage of the hashChanged
      + I think it's because we end up firing two hashChangeds with the same key!
      + doesn't seem to be an issue, but will follow
  + could repurpose event queue as list of all outstanding (unresolved) deferreds?
  + handler_hashChanged creates/picks up context
    + needs to pass it down to fire_scroll to get to handler_scrolled
      + I think that's why parenting is important
      + don't think we need to parent
      + because parent has a .done() waiting on the child
        + then parent will resolve itself
  + alsoRemove = false
    + that way we only remove things from the event queue once they're resolved
    + this is slightly more complicated
      + we sort of need two queues
        1 for unresolved events
        2 for unhandled events
          + these are fired events that have yet to be handled
          + we need them to be handled only once
            + but they may take a long time to get resolved
            = pending
    + make mergeOrPush look for an existing entry in the unhandled queue
      + this is worth doing
        + because at the moment two handlers can resolve the same single eventContext
          + leaving some contexts unresolved
          = come back to this
  + I think we're creating the 0,0 scroll events
    + example doesn't experience any 0,0 events
      + http://www.lightenna.com/staticpages/jsfiddle/hashseq/index.html#!seq=14
    + test: try and remove all the scrollTop calls for now
      + didn't make a difference
  = drowning in complexity, need to simplify

* build jsfiddle demo of basic setup
  + move fiddle to htdocs root
  + work out what causes the scroll0,0 event
    + vertical scroll fine
    + horizontal scroll fine
    + libraries ERROR
      - turns out it was the QUnit library

* it's time to tear out and refactor the hash changes
  + start by pulling out the init stuff
    + just attach the hash listener and see what it's like
    = works ok, but reload problematic
      + QUnit!

* new idea
  + always draw page-0
    + then jump up to page-X
  = abandoned for now

* straight jump from high-seq to low-seq (not reload)
  + seems like we're catching the position too late
  + or not locking the position early enough
  + there are two routes through a handler_hashChanged
    + setScrollPosition, which triggers other stuff
    + refreshVisibility
  + it's not the clearest split
    + really need to nail those two cases
      + and come up with a clearer definition of how they're different
  + test cases

    + cold load 0 = fine
      + handler_hashChanged(seq=0 or '') from init()
        + noChanges:refreshVisibility
          + setVisibleAll
          + refreshSelected

    + cold load low seq = fine
      1 handler_hashChanged(seq=6) from init()
        + seqChanged:setScrollPosition(931,0)
     2a handler_scrolled(0,0)
      3 handler_hashChanged(seq=6, forceUpdate)
     2b handler_scrolled(931,0)
      4 handler_scrolled_eventProcess(931)
        + images appear
      5 handler_scrolled(557)
      6 handler_scrolled_eventProcess(557)

    + cold load high seq = fine
      1 handler_hashChanged(seq=208) from init()
        + seqChanged:setScrollPosition(32418,0)
    [2a]handler_scrolled(0,0)
    [2b]handler_scrolled(32418,0)
      3 handler_hashChanged(seq=208, forceUpdate)
      2 handler_scrolled(32418,0)
      4 handler_scrolled_eventProcess(32418)
        + images appear
      5 handler_scrolled(31919,0), nullified
     10 nullify scroll0,0 setScrollPosition

    + load 0 skip low = fine
      + handler_hashChanged
      + handler_scrolled

    + load low skip high = workable problem

    + load high skip low = same workable problem
      1 handler_hashChanged(seq=6) from init()
        + seqChanged:setScrollPosition(931,0)
     2b handler_scrolled(931,0)
        + images appear
      3 handler_scrolled_eventProcess(931)

* turn off JS
  + work on no-js version
  + disable js all together to see what it looks like

* run tests from htdocs directory
  phpunit -c app/

* cached images not writing x-bound/y-bound
  + injectargs is injecting them too late
    + well after we've used getOrientation

* images with IPTC special whatsit create error

* alignment of menu icon

* make sfun header expand on hover using CSS-only in non-JS version
  + actually all the header actions require JS
    + so better not to show menu at all

* create hamburger icon for sfun header

* no-js or disabled-js
  + show all the thumbnails
  + no-js uses noscript alternative
  + disabled-js will have to manually flip them in
    + done in its own if clause

* cold load seq=1 doesn't draw anything
  + cold load seq=0 doing the same

