
* dynamically add AddonBundle's routing.yml
  + currently it's a static reference in app/routing.yml
lightenna_structured_addon:
    resource: "@LightennaStructuredAddonBundle/Resources/config/routing.yml"
    prefix:   /
    + which breaks if it's not present

* look up how to get ? parameters using symfony routes
  + canvas_width/height, tile_width/height
  + not sure how to handle scale factor
    + so that we can share code between getDyanmic and getDZI

* check an individual image's metadata
  + after a deserialise
    + I think we're not pulling the fields in properly
    + confirmed
  = lookup a progressive deserialize
    + there must be someone who's done it

* create TileMaker class
  + from existing nebula code
  + check canvas size is coming out sensibly

* make image tile
  + setup as a generic service
  + could be making a small tile (256x256) as part of a zoomable
  + could be making a large collage (1600x800) for a social share
  + cache
    + should be able to share .htaccess code
    + /image goes into the image folder
      + so choose route that maps to a different folder
      + e.g. /dyntile

* can't fullscreen a high seq image
  + it doesn't go far enough right
    + I suspect this is a viewport clip
  + we're trying to scroll to a place that's north of possible
    + it's only when the images go fullscreen (breadth 1)
      + that it will be possible to get there
  + see if this is caused by my changes to api_triggerScroll
    + nope
    + doesn't make any difference
  + jumping into and out of fullscreen
    + both problematic
    + hash:seq=27... event looks fine
      + but for some reason we get dumped somewhere else
      + URL isn't updated
    + interestingly it's ok until we're in a very widescreen browser
      + firebug loaded OR just wide stumpy
  + works going to fullscreen for all=pimages
    + except final one
      + I suspect it's an edge of screen issue
  + it's flow related
    + without flow we don't get the jump back
      + which must be cells resize
  + it's viewport height dependent
    + can get to penultimate one when full-height
      + but can't get to penultimate when firebug loaded

* GA on sfun
  + use _gaq track to push events
    = needs internet connection for reference

* 302s are going back to the browser
  + we want to hide the fact that the URL is changing
    + if at all possible
  + there's no need for the browser to know
    + that the image is being served from a cache
    = needs internet connection for reference

* chrome shuffles towards 0
  + when refreshing non-zero seq
    + related to chrome's remembering 

* wheeling through narrow images on widescreen display
  + can get stuck
    + I think it's to do with offseq
    + perhaps offseq > last image width

* make test suite work again
  + whole thing seems to have only 1 error
    + introduced by testLayoutListing
    + which is a permission denied

* error images are doing strange things
  + on lappy they're way too small

* minor bug: GA track event generating a few too many scroll events
  + scroll events do settle
    + they work nicely a lot of the time
  + it's including the ones that we generate
    + clicking an image fullscreen
      + generates a scroll event
      + look for a flag that holds whether we generated the event or not
    + I suspect we're not pushing a context through
      + it's probably just a scroll
        + check?
      + there quite a complex journey
        + from hashChange to fireScroll to handlerScrolled
      + fireScroll and handlerScrolled don't match up
        + are they different events?
--o--
* image click generates scroll event
  + fine but the event get tracked
  + this is a very minor bug now
    + not sure it's worth resolving now
  + means that we have a few too many scroll events in the analytics
    + but at the moment that's not the priority

* feature: focus the light beam
  + make it surround just the current cell

* work on flow2
  + the cellsResize() approach is the right call
    + doing it in visible batches is the most efficient
  + so we want to use the existing hooks

* subfolder image Ніжний_ранковий_світло.jpg
  + creates problems
  + MetadataFileReader:66
print('Error: problem reading '.$this->file_part_leaf.', length '.strlen($imgdata).' bytes'."<br />\r\n");

* fix 500s caused by Malformed UTF-8 characters
  + suspect this is to do with getNameOriginalCharset()
    + don't seem to show up on wikimedia images

* proper 404/500 error page
  + at the moment we show the Symfony error page
    + which is a security risk

* look for .shareable.jpg
  + setup HEAD og: tag if there is
  + test twitter/facebook card

* tweet first image gallery

* bigger-smaller bug
  + cells start out a certain width
    + then pop down to a smaller width
      + maybe associated with reaching end (Ctrl+End)
      + maybe associated with 

* event litter
  + some events aren't getting resolved neatly
    + and they're littering the event queue
    + where they collide with real events
  + watch for stuff that's only getting cleared out by the 'expires'
    + seems to be the selected:seq=X events
      + could be that we're orphaning a context in refreshSelected()
  + good news is that the only litter is created by the offseq push

* changing between pages preserves offseq
  + needs to be recalculated really
    + otherwise images no longer appear centred
      + because pages have different cell widths
      + good to clear/recalc offseq everytime cell width changes
  + browse around in many-foldered image set
    + see what the experience is like
  + there aren't any pages in the demo at the moment
    + so it can definitely wait until next release

* faster image delivery
  + write .htaccess lookup for cached image files
wget -qO- $url &> /dev/null
wget -qO- http://localhost:8097/fish &> /dev/null
  + identify command that will show forwarding

* test BAL 10k folder
  + see how layout performs

* bug: scrolling from left or right leaves 1-up images stuck to left edge [minor]
  + they ought to get centred again

* bug: if values are redefined in later .ini
  + make sure they overwrite the predecessors
    + not form an array of candidates (as currently)
  + solution may be to eval those candidate arrays
    + and take the last value

* bug #1101: shouldn't write loaded_width = 200 to original file
  + need to change out/unset those values before updateOriginal() call

* manually compose sharing image
  + use that javascript that was posted up online
    + create it once
  + transfer manually composed image from discus to demo.sfun
  + put the correct metadata on the page accordingly

--- first share ---

* video metadata isn't making it to the video

* feature: show all metadata on first load
  + only if we've loaded metadata for all images
    + that's hard to tell
    + we need some kind of state on the cell/img to flag it
  + cleaned up display of .meta.base when metadata hasn't been loaded
    + so now it's ok to show metadata whilst loading

* flv video
  + just for fun

* install linux tool to read image metadata
  + xv or xview or something
    + exiv2

* detect if database exists
  + create it if it doesn't
    + might need to be a try {} catch

* devise a videometadata test
  + I'd like to refactor VideoMetadata
    + to use protected instead of public
  + but we need some kind of test to guard against regression

* store (persist) metadata in sqlite DB
  + just writing rows is a win
    + demonstrates that it can work

* try and get mediacache filenames to be readable
  + they don't need to be pretty
    + but it would be a big plus to be able to actually see the data
  + I think simple escaping is the way forward
    + it's not pretty but it'll work
  + escaping
    + should work with apache mod_rewrite internal function 'unescape'
http://httpd.apache.org/docs/current/rewrite/rewritemap.html#int
    + that way we can do a simple direct cache lookup
      + save instantiating PHP at all

* browsing experience on mobile/touch device
  + jumping around, not updating offseq, delay on fullscreen

* bug: image border needs tweaking
  + it's currently slightly too light
    + didn't update it when we did the cell tint adjustment

* bug: first load on imageset (uncached) doesn't up-res all visible images
  + I suspect it's because it doesn't recognise them as visible
    + requires cache clear to demonstrate

* bug: mobile browsers only use half the height
  + when horizontal scrolling (direction=x)

* bug: non-imagesnap scroll locking
  + seems to happen when scroll events queue up
  + it's sufficiently annoying that it needs never to happen
  + start by making sure the scroll event is fired

* think about offseq for page up/down
  + think about offseq for wheel up/down
    + think it's a matter of preserving the current offseq on a wheel
--o--
* resize needs to refresh the hashed offseq
  + in order to maintain centring
    + works when just applied
  + also need to buffer fired events
  + for some reason it's not putting it in the centre
    + probably needs a force
    + introduced forcing for offseqChanged for now
--o--
* scroll doesn't always work full screen
  + doesn't go forward
    + goes back in two-steps

* first read (when using imagemeta) no column resizing
  + ratio is 1.5
  + but it is correct when we do a resize

* debug mx-hd
  + 0 byte png throwing errors

* scrolling and clicking fullscreen is still very buggy on slow connections
  + keys stop working while waiting for images to load
    + I don't think it's launchable like this
  + discovered on Mac on train with bluetooth connection
    + even though elan VM was running locally

* feature: share preview
  + re-purpose buttons share code
    + show nice view of some images
    + best to do that with flow

* feature: double-run the test suite
  + now that we're vertical by default
    + let's insert a set of tests that run twice
      + once horizontal and once vertical
  + options
    + parameterise existing tests
    + label anonymous functions and re-call
    + push onto array
      + not a straight forward result
      + retest after last bug fix
      + push doesn't really work
        + because the time when the tests are called
          + not equal to the time the tests are queued

* bug: js test suite needs sorting out
  + it's in a bit of a mess, but sort of ok
    + 2 bad tests

* look and feel on IPTC editing
  + show HTML5 empty text in fields that haven't been filled out yet
    + use default detection
      + in (default -> blank) and out (blank -> default)
      + because our default text won't mean anything to most people
  + return should move to next form field
    + until it gets to the last one
      + then submit
  + show little icons next to form fields
    + reinforce what they mean
      + on hover the icons should show the field name
  + show form fields with same spacing as display
    + again makes for a consistent feel

* feature: hover on fullscreen smaller
  + black faded overlay covers 30% of the image
    + it's much too distracting and there's no way to turn it off

* feature: consider centring (offseq) image in b2
  + currently centring only applies to fullscreen
    + it's just nicer to look at images in the middle of the window
    + rather than in the top corner

* feature: align images to outside edge of border
  + when aligning an image
    + we don't want to butt the image up against the edge
      + because it gives the impression of a 
      + crop
  + also do this at this top and bottom (vertical scroll)
    + or left and right (horizontal scroll)

* bug: chrome blacks out image when editing metadata
  + seems to just be a rendering bug
    + may be able to get around it by apply a class after appending

* feature: directories shouldn't go to the edges
  + they're just too big
  + delay this just long enough to get wikimedia1 out

* feature: directories ALWAYS need a name
  + file systems encourage users to think about directories by name

* optimisation: swap out $(this) references to use cached copy
  + from
        var $ent = $(this);
  + to
        var $ent = $img($(this).data('seq'));
  + important wherever there's a cachedFind/Get/Set downstream

* optimisation: experiment with using this.offsetLeft/Top instead of $(img).offset().left/top

* feature: open folder in explorer
  + nice to be able to pop-up the folder in Windows/Mac OS X explorer

* feature: move imgmetric to top-right
  + make its text right aligning

* bug: image 0 in fullscreen mode
  + alignment looks wrong because there's no left hand border
    + could artificially introduce one using offseq
      + just need to allow a bit of negative document

* bug: massive image sets in zips slow
  + takes too long to prep the HTML
    + seems to be a zip problem
      + large image sets in folders are fine

* bug: performSubstitution test [1] selects first image [i1]
  + instead of first general file

* feature: directory expansion
  + could maintain a URL state of the expanded and upexpanded directories
    + clicking a folder expands it
      + adds it to the expansion list
  + all folders expanded by default
  + or maybe partly expaned by default
    + show the first n images from the folder
      + a little bit like directories now
        + but whole column (minor) view

* feature: directory explorer overlay
  + thinking about some kind of directory overlay for sfun
    + frequently I want to quickly find another directory
      + 1 up
      + completely different part of the tree

* bug: prevent flash of unbound image
  + shows up in Firefox/bug because ultra-wide window
  + when vertical scrolling through single images (b=1,d=y
    + we could remember a default bound for all first loads
      + will catch most of them
      + probably more than using the image
    + better as a combination
      + if we have a landscape image
        + that's y-bound
          + remember y-bound
          + because it's likely that future images will also be y-bound
      + could do a sort of thresholding thing
        + based on data-ratio
    + for non-flow all cells are the same size
      + so working out what a typical cell size is (as a ratio)
        + then comparing to data-ratio
        + would give us a good approximation
--o--
* bug: directory thumbnails need to load bounded
  + partial flash looks weird
    = easiest to debug on a PC with larger image sets

* bug: large zip folders are slow to show
  + I suspect we're re-opening the zip for every image

* optimisation: take PHP out of the loop for cached images
  + this potentially reduces thumbnail loads from 100ms to 10ms
    + it might not work, but it's a game changer if it does
  + change caching to use mod_rewrite
  http://httpd.apache.org/docs/current/mod/mod_rewrite.html#rewritemap
  + probably need to use RewriteMap escape function
    + don't worry about long filenames
    + do terminate with .dat
  + start by checking the PHP logic
    + it may not be possible to do a pure cache lookup without using any PHP
    + things like shares/aliases may get in the way
-- investigate doing this next --
* feature: re-write image URLs to be IIIF 2.0 compliant
  + checkout how IIIF feels about an/arbitrary/number/of/chunks in the path
    + before /width/200/height/.. etc

* push forward with flow
  + it's a really beautiful layout system
* re-enable flow
  + debug and optimise
    + it's close
--o--
* not buffering quite enough
  + the scroll feels sticky
    + this is fine on non-flow
    + consider as part of flow
--o--
* worth optimising flow because it needs to feel snappy
  + not sure if this is viable for a first release
    + I think flow needs quite a lot more work
--then--
* forward scroll newbies
  + newly visible images are coming into view too far apart
    + better to assume a narrower cell width then correct it
    + take an average major
      + maintain everytime we shrink a cell
--then--
* need to wait until there are no scroll events before realigning flow
  + otherwise scrollbar goes all over the place
  + could search the eventQueue for any other scroll: events
    + could flag each event as started
  + does buffering solve it?
    + means that repeat calls get ignored
      + not sure
      + worth investigating first

* feature: make sfun menu bar slide down
  + also slide down image set
  + use CSS3 animated transition for both

* feature: image-is-reresing animation
  + deblur (50% -> 0% gaussian blur)
  + saturate (10% -> 0% grayscale)
  + animation should be css3
http://www.hongkiat.com/blog/css-filter/

* optimisation: we're calling cellsResize way too much
  + at least twice per scroll

* optimisation: we spend quite a lot of time waiting for the wrong images to load
  + browser can only fetch 6/8 at a time from a single domain
    + that means there's a longer gap than necessary between
      + 200px thumbnail and
      + 500px final
  + options
    + hashbang arg to stipulate the first resolution to load (think last_longest)
    + delay processing visnear until we've got all the high-res for visible/vispart
      + technically harder, but neater
        + would make it seem snappier
          + page load is about 2s
          + currently full-res snap-in is at 2s
          + reordering would mean full-res snap-in would be at about 1.5s

* optimisation: currently re-bounding/re-resing images unnecessarily
  + really want to maintain some state on each image
    + only wany to re-anything it if the context has changed
    + there are some events that affect cells
      1 resize: cells need rebounding/reresing
      2 breadth change:
      3 direction change:
    + many events don't change cells (once first loaded)
      3 seq change
  + currently we're doing a bunch of things everytime
    + everytime an image makes the transition
      + from visnear/visno -> visible/vispart

* FEATURE: show semi-opaque numbers in circles over each image on a direction change
    + to reflect order of images
    + draw lines between 

* FEATURE: video

* instead of requesting metadata
  + could just request an image of the size we want
    + (guess that it might be available)
    + and display whatever comes back
      + then request metadata asynchronously
        + and probably for everything rather than just the visibles

* imgmetric as mini bar chart
  + show percentage in background too
    + visually reinforce when you're looking at massive images (small)

* page up/down should advance to next image that partially off screen

* vertical mode needs work
  + catch up js with horizontal
    + should work properly in test suite too

* show video entries in directory thumbnails

* show imgmetric on videos

* single entry in folder
  + or fewer entries that a single column
  + align left, not centre
    + which will mean it doesn't matter if we turn off border-left

* never show thumbnails on mediacache

* shuffle directories to top
  + like in windows

* introduce HTML for markers
  + directories/images/files
  + but don't worry too much about what markers we insert to start with

* shuffle non-image files to bottom
  + just for convenience

* test using app.php for everything
  + is it possible to make elan an exception (and use app_dev.php)

* think about javascript changing cell percentage based on mean row height/column width
  + alternative is dynamically reducing column cell widths, column by column
    + alternative is better I think

* cookie header options
  + to remember what we were looking at
  + think about hash-bang/url change too

* safari sometimes-sometimes-not resizing images
  + see iPad

* folders maintain square aspect in landscape cells
  + make x-bound
    + write javascript to detect div.folder width and flip class
    + write y-bound class specifically for div.folder

* Redraw folders at 1440x1080
  + 4:3

* Add ../ up arrow to directory listings
* create file icon

* Nice looking header icon (sf in circle with chunk bitten out)
* Rotate header icon on rollover header expand

* Horizontal/verical icon
* Light/dark icon

* snameed jQueryUI scroller for number of images wide/high

* make imagemeta returned JSON take IIIF Image API format

* overwrite settings that have been cached in mediacache images
  + e.g. metadata_editable
  + when serialized into a file
    + the file-loaded-setting currently takes precedence over the global setting
    + it shouldn't

* Fail nicely when a file/directory/path element doesn't exist

* Using Project sheet in Google drive for major functional items
https://docs.google.com/a/lightenna.com/spreadsheet/ccc?key=0AuXNj3kHNsfddFhwTGZpcERMd1JweTVuMEFoS3h6YUE&usp=drive_web#gid=0










































Done
----

* setup paths bin

* install composer

* use composer to install symfony2

# install composer into bin directory using downloaded install script
php bin\install-composer.php --install-dir bin

* create a project
php -c conf bin\composer.phar create-project symfony/framework-standard-edition ./vendor/symfony2/ 

* commit everything to an open repo

* test basic route on prod

* create directory indexer like before
  + but under symfony

* setup php-dev server for dev if caching is annoying
  = didn't have to, configured normal apache to use app-dev

* setup model for record(directoryEntry)

* setup controller and route

* setup directory, file and record->directory->zip

* never add trailing / to directories
  + and make thumbnail paths work using linkpath

* Double data/ for directories with trailing /
  + http://localhost:8080/file/data/

* Images not showing from zips

* Error image

* no route found for /file

* double // for /file/ or /file

* 404 for for / or <blank>

* write test function for jazzy new performFilenameSubstitution()
  + extend to cover zips

* clipping bug when used *with* resize
  + suspect it's to do with not resetting width and height
    + better to re-read

* Write tests for image resize/clip

* Internal server error on really big image requests
  + if requested size is greater than image, just return image
  + http://sfun.elan/image/data/alice%20eve.zip/alice%20eve/alice-eve-06.jpg~args&thumb=true&maxwidth=4250

* Add FileReader, then MetadataFileReader, then CachingMetadataFileReader
  + but only after we've made the current read work
    + unless we're refactoring in the wrong direction

* Make test suite work for ViewController URL transformations plus new FileReader ones
  + sort of, ok for now

* Rewrite ViewController to use FileReader

* Make Fileview work using FileReader family classes

* Try getListing on single file
  + should just return that file

* Fix zip_part being given all the args

* Make Imageview work using FileReader family

* Weed out old tests

* Deprecate old ViewController code as using FileReader instead

* Double appending filename to end of video in stats->file

* Get cache working for video

* Need to make mediacache directory for -linux install and enable for selinux

* ../ bug in splitFilePath

* write more tests for FileReader
  + crop child as well as crop parent within zip
  + e.g. http://sfun.elan/file/data/alice%20eve.zip/ is wrong

* add super-short video to test suite

* handle large images sanely

* add test to check that two different timecodes produce two different frames
  + and same timecode produces identical frame

* fix missing video thumbnails
  + it's SELinux

* add support for .png
  + process png as png, not jpeg

* mfr bug for test suite
  + whenever we open a zip
    + stats->file is the zip folder name
    + stats->name is the file name

* Nested folders in zips should be links
  + then think about collapsing

* factor out CacheHelper

* Reading all the files for resolution/shape is too slow
  + introduce caching by default

* Javascript resolution check and class apply
  + x-bound and y-bound
    + have temporarily disabled cache to apply this
logic check
cr/ir
portrait container 200x300 ratio = 2/3 = 0.66
wide image = 300x200 ratio = 3/2 = 1.5
bound, 0.66/1.5 = 0.4 = <=1 = x

portrait image = 200x300 ratio = 2/3 = 0.66
bound, 0.66/0.66 = 1.0 = <=1 = x

v-portrait container 150x300 ratio = 1.5/3 = 0.5
bound, 0.66/0.5 = 1.33 = >1 = y

v-wide container 400x200 ratio = 4/2 = 2.0
wide image = 300x200 ratio = 3/2 = 1.33
bound, 2.0/1.33 = 1.66 = >1 = y

square image = 200x200 ratio = 2/2 = 1.0
bound, 2.0/1.0 = 2.0 = >1 = y

portrait image = 100x200 ratio = 0.5
bound, 2.0/0.5 = 4.0 = >1 = y

* not 100% on mini-pictures in folder
  + probably 20%

* folder image and overlay
  + small image alignment

* 100% height on directory background
  + if that's possible

* send out transparent gif/png for missing previews

* strange thumbnail zooming thing
  + thumbnails getting big and blurry
    + because the point we store back to the cache is after cropping
    + change mfr->cache() call point or add clipwidth/height to cache keys

* every page is too high
  + being given a redundant vertical scollbar
    + try making Symfony use production version

* image vertical centering

* back to directory view doesn't bound images properly
-- same as --
* javascript image classes failing
  + works on refresh, but not always on first load
    + disable caching to debug
      + doesn't happen reliably, needs more investigation

* javascript re-assess x-bound or y-bound on resize

* tweak sfac on js y->x scrolling

* set screen-x/y as percennamee
  + covers pre-update scenario to fix quirky drags
* check chrome re-bound

* mac dragging around the edge messes up sideways scroll
  = solved by stopping bubble

* Either move $this->stats down to MetadataFileReader
  + or rename as AwareFileReader
  = refactored, much neater now

* Convert args to object

* Don't cache error img
  + test suite failing because error image comparison fails

* Repeated vertical (flow-y) resize toggles between rows
  + slightly funny stuff going on
    + jitters between 2 and 3 rows
    ? could be finding a % in the id because we set one?
  + test drag behaviours
  = not perfect, but good enough

* Windows test suite errors

* Re-do folder from ai to produce authoritative psd
  = not psd, but exported from ai

* Debug image
  + turns out to be a artefact of an image -> in a zip -> in a shared folder
    + equally only applies to thumbnails (which is very strange)

* Create a test share and mount it into the structured tests directory
  + that way it should never affect users
    + and can provide that

* Folders on dark background

* Folders (part 1) maintain square aspect in landscape cells
  + fix positioning

* Fix nasty selection bug
  = test, done I think

* Producing two cache entries for a single image
  + don't save to cache if this image was loaded from the cache
    + ah ha, might be already protected for that
    - mmm, not
  = fixed by ensuring that we don't always generate a new cache key
    + which isn't necessary when rewriting from the cache

* Cachekey not set for directory listing
  + except first entry
  + cache is being used for all the images
    + but for some reason their cachekey isn't making it into the directory listing
    + that may not be a problem, but worth investigating
  + this is true for both zips and normal directory listings
    + it means we're not finding cached entries
      + which in turn means we never fetch metadata for dir entries
  + actually weren't putting any cachekeys in
    + trick is to use the right cache key
      + always the one for the file in situ, not in the cache
  + right, now we're getting different cachekeys because
    1. actually image is a restricted thumbnail, so uses args
    2. is just an image path, so has no args
    + verify that's true

* Clean up metadata that gets stored in cache files
  + don't need all the spurious stuff
  + rewrite names
    + width_original
    + height_original

* Think of a way to store data-native-width and data-native-height in the cached image metadata
  + worth finding ways to store and retreive image metadata anyway
    + plus it enables re-res
  + start with cache function
    + write in native-width/height
* Use cached data to write native width/height into data fields

* Round newwidth/height

* Fix test suite errors

* write getFilename and getFullname tests for test suite
  + important to have a record somewhere of what these functions should return

* video thumbnails need metadata too

* bug
probably caused by
http://sfun.elan/image/data/alice%20eve.zip/alice%20eve/alice-eve-jiggle-ibbZy7SI8fCxXB.gif~args&thumb=true&maxlongest=200&
http://sfun.elan/file/data/alice%20eve.zip/alice%20eve/
getimagesize(): Read error! in /var/www/git/github.com/structuredfun-linux/structured/htdocs/src/Lightenna/StructuredBundle/DependencyInjection/CachedMetadataFileReader.php on line 194 
+ cache is producing bad gif
  + need to make it produce a gif, but a wrapped jpg

* test out showing display-size in imgmetric in js
  + then come back to html

* get relative position of image within parent container
  + then apply to imgmetric
    + parent container is shared parent of both img and imgmetric
  = did using absolute coords
    - relative (using jquery.position() instead of offset) doesn't put it anywhere close

* bug: imagemeta is requested for each image twice
  + look at Firebug Net tab

* bug: imagemeta doesn't request images at right (bigger) size
  + got to sort of pass waitForLoad right through the chain

* use js to re-write all image URLs to local hashbangs
  + indirect via a handler rather than rewrite

* right-arrow, down-arrow
  + go one frame right

* click goes to flow-1
  + and jumps to that image

* firefox scaling factor
  + for scroll-x

* re-res directory thumbnails as per normal images
  = decided not to re-res for jq load
    + but have improved res to 200px

* title on folders

* get state in one place
  + URL: breadth, image seq, direction
    + fall back to HTML if not set
  + make nice functions that cascade
  ? do we want to cache in javascript?
    ? could this be a good time to embed a framework?

* back to page without explicit breadth
  + needs default

* clicking on an image pushes state
  + but it should only do that if the URL is different
  + otherwise the history queues up with duplicate entries
    + which makes 'back' confusing

* imageAdvance crashes browser

* need to detect if next/previous pushes us on to a new page
  + e.g. always for 1 up
  + only scrollTo() if advancing to new page

* scrollTo breaks click
  + advance to a high image
  + go fullscreen
  + advance a few more (to about 3rd or 4th)
  + go back to b2
    + think this is just like the upper end crop

* 1 minor bug in linux test suite
  + also just 1 (same 1) in windows

* reduce apache to 2 concurrent threads
  + should never use more than 2 cores
    + see if that helps with the responsiveness of the page
      - otherwise may need to use blank images
  + working for windows
    + not going to apply to linux config because we don't have the same whole-app

* time for a front-end test suite
  + introduce a basic QUnit
  + introduce a #test
    + as a new button for the header in its own file
  = half way through this
    + press on with mustache template

* return jumps back to previous image
  + but doesn't always go back to
  + seems to work ok
    + will revive if I can replicate again

* arrows get stuck sometimes
  + seems like history.js is playing up
    + get strange behaviour with advance (+/-) where it won't go one direction

* advance should wrap around

* after a click, need to focus on an element so we get keypresses
  + try jquery focus
    - it's not a focus
    + left and right arrows work, but return does not
    = just needed a preventDefault to stop the return triggering a URL refresh

* ctrl+home/ctrl+end

* scrolling needs to advance seq selection to the right image
  + important because we can't use page up/down or arrow keys after scrolling

* resize (refreshCells) event in Chrome
  + creating a new image and then measuring its width and height doesn't work
    + ix = iy = 0
  + solved by using an onload

* probably need to invest time in the javascript test suite
  + I keep exposing stuff that doesn't work on my non-test browser
    + once I've started it will flow
    = got something started

* only swap out visible images
  + swapping them all is too intensive
    + probably should try to avoid going over about 50 x 1000
      + add as line in config file
  + made progress on this
    + may return to it

* checkBound is now async
  + we need to do all the async stuff before trying to do the sync stuff
    + build a loaded image size map on image reload
    + build a cell size map on window resize
  + it's another level of complexity
    + it means we're partly reliant on the DOM, partly on js proxy objects
  + this is important
    + we need to get some kind of promise setup

* work on page load speed
  + currently reloading all images (from cache) on every checkImageBounds
    + solved using test

* first load (uncached) makes a mess of image bounds
  + it's because we've not got a loaded-width/height

* imgmetric scattered all over the page after switching from b=2 to b=1
  = ok for now
* current loading 250s en route to loading 500s
  + suspect it's to do with image bounds
  = ok for now

* extra scollbar, bit too much margin somewhere
  http://10.12.1.160:8097/file/data/alice%20eve.zip/alice%20eve/

* protect handler_scroll from itself
  - I think it's getting stuck searching for img.visible when there aren't any
* handler_scroll shouldn't be called when the page loads

* need to add scroll handler
  + at the moment we trap against mousewheel
    + but it's possible to drag the scrollbar

* setVisibleByScroll
  + tricky
    + can't quite decide if it should just scroll and
      + let the scroll handler sort out all the image
    + I think yes

* sort of moving everything out of init() now
  + and triggering hash change instead

* something is triggering a scroll event to 0,0
  + happens during page load
  + e.g. http://10.12.1.120:8097/file/structured/tests/data/20-image_folder/#breadth=2&seq=9
  + may not actually be resolvable
  = have inserted a jump-back using ignored scroll:0,0 event

* change out all the clicks to be hash changes
  = done most of them

* change image seq to entity seq
  + we want to be able to select folders
  + throws error on 
    + http://10.12.1.120:8097/file/playspace
  + because directory features in middle of images
  = not without issues but working pretty well

* change cache file extension into .dat
  + avoid mediacache leak

* test suite error
  + only occurs when running a second time
  + it's a cache error
  + need to keep hold of the original extension

* first load after cache clear
  + not reresing images
  + seems like we're not waiting for image load before firing imagemeta request

*** have set a cache clear every run! ***
  + but only from my local settings

* need to be able to merge in settings from config files

* could be double-loading the metadata
  + would explain why we're swapping out the images twice

* NaN% on certain images
  + there's an ordering of concurrent ops that allows this
  + problem is that the image is loaded
    - but the imagemeta call hasn't returned yet
    + so we're trying to compute %age based on width/height-native
    + but they don't exist yet
  = have protected
    + watch for images not re-resing

* double end doesn't work
  + seems to only be in larger datasets
    + this happens when we end up with no .visible entries
      + we do a select on a jqEnt that doesn't exist
        + protect against that
      + then fix the forward

* right arrow from sMAXb1
  + should wrap around to show s0b1
  - but get error

* Apache builds for Windows
  + http://www.apachelounge.com/download/additional/

* don't load all thumbnails in very large data sets
  + still quite slow on load
    + think js op is slow
  + also doesn't work
  + need to do it the lazy loading way
    + http://www.appelsiini.net/projects/lazyload
    + start by implementing noscript version
  = working, may need to do more

* dragging in very large image set
  - jumps back to zero every drag

* key press (like ctrl+end/home) triggers hash change
  + hash change loses key focus from window
    + need to preserve so we can 
  = seems to be working for now

* fullscreen from visible images
  + needs to refreshImage

* images not displaying
  + problem doesn't seem to be caused by the refactoring
  + the cells are slightly outside the window (top:-1, left:-1)

* move selectable, selected, visible up to cell
  + test thoroughly

* clean up isVis to make it reliable for on-screen

* fix end bug

* fix test suite
  + end doesn't select last entry
    + it's toggling between 838 and 836
    + which I think is caused by isVis getting it wrong
      + test using #!seq=8
    + do it properly with unit tests
      + tricky to test
    + best to do it with the test suite

* extend test suite
  + test visibility
    + scroll to start, scroll to end, scroll to middle
    + test all visibles in one block (no littering)

* extend test suite
  + test reres
    + reres of first x images

* need to work out how to handle tests keyed upon delayed events
  + deferred promises are the way
    - but passing them around is tricky
  + either parent thing can make a queue
    + and pass it to all the sub functions
  + or originate in each sub function
    + and then aggregate queues in parent functions
  = brilliant piece on deferred patterns
    http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt2-practical-use

* fullscreen of image 0 needs to hide all imgmetrics

* fullscreen/return should toggle
  + between b1 and bPrevious

* changing from b2 to b1
  + need to do another refreshCells at least on current image
    + because cell shape may have changed dramatically

* reload page from final entry doesn't swap out images properly
  + seems not to be loading thumbnails
    + so the 500 request doesn't get any metadata

* arrow-key / home after scroll

* pull forward UI test suite

* rewrite isVisible function to cope with partials
  + frequently images are partly on screen
    + but not treated as visible

* dropping back from fullscreen, checkImageRes swaps out all the images
  + not just the visible ones
    + this is all to do with async stuff
    + we need to wait for the hash updates to complete before doing a checkimg

* not loading right image just in time
  + in fullscreen mode
    + loading one image behind

* this test suite stuff is so important
  + I've just recovered from breaking it
    + a break that wouldn't have occurred if I had a reliable test suite
    + and could have been hunting for regressions all the time!

* re-write hashTable using Object.create
  + put in separate file for now
    + can aggregate later
  = thought better of
    + not enough instantiation to merit prototypes


* force imagemeta to return meta

* modify the numbEventQueue to be deferreds manager
    + that's a pretty good handler
    + needs a hash (string), done function pointer and parent
  + looking pretty good
    + need to find a way to pass deferreds through the eventQueue
      + will circle back to this once we've got deferred cascading through the actual event handlers
* expose deferred through exported API
  + need to create deferred first
    + then pass into following event handlers
  + so we can queue up dependent functions
    + like the test functions
  + we get into complications when we're trying to push a deferred through a hash update
    + there are potentially many layers
      + one hash update, triggers scroll update, triggers hash update
      + nice to great some kind of general rule
  + how about eventQueue for storing the deferred
    + create when eventQueue item created
    + pick it up in the handler
      + could even link up parent events
        + done when say setScrollPosition called indirectly by a handler
  + maybe it's a combination metaphor
    + we need eventQueue to bridge between code->handler
      + because it's async
    + how to do parenting
      + class-wide var is complicated because it could get messed up
        + it's analogous to the old-school global variable
      + passing deferred from function to function requires care
        + it's going to need elaborate lacing together
        + could pass event object around
  + making eventQueue fairly smart
    + tries to wrap up as much of the promise logic as possible
      + because then it's all in one place
        + if a 'parent' set it does get resolved once its child is resolved
  - beginning to wonder if the necessary deferred tree will be just too complicated
    + it reaches through almost everything
      + might need to rewrite most ops as synchronous
    + not sure
    + using the #hash is elegant
  + eventContext originators
    + fire_
  + eventContext decorators/ornaments
    + everything else
  + eventContext resolvers
    + terminals that create a local context and resolve
  + execution summary
    To numb a listener, at the point we decide to numb it
      eventQueue.pushChild(eventContext, { 'replaceEvent': function(){} })
    To pass a context on, which may have been numbed upstream
      eventContext
  + what about passing
    + everything we pass it into
      + needs to be able to pass it out?
  + check the event story
    + fire_scrollUpdate creates eventContext(1)
    + handler_scrolled receives eventContext(1)
      + calls refreshVisibility with same context(1)
        + refreshVisibility doesn't do anything async itself, so no forking
        + calls setVisibleAll with eventContext(1)
          + calls setVisibleImage with eventContext(1)
            + calls refreshImage with eventContext(1)
              + calls refreshBounds with eventContext(1)
                + calls getLoadedResolution with eventContext(1)
                  + creates it's own child eventContext(2) using pushChild
                    + sets up stuff to happen
                    + returns eventContext(2) so that parents can queue up other stuff for AFTER this happens
                    + when stuff happens the child resolves (eventContext(2) resolves)
                    + the things that the parent queued up start getting executed
                  + returns eventContext(2) if it scheduled stuff, or eventContext(1) if it didn't
                + refreshBounds then queues stuff against the eventContext it receives (2/1)
              + refreshImage then queues stuff against the eventContext it receives
  + remember
    + pushChild only when we're about to WAIT for something to happen (e.g. an actual async wait, e.g. image load)
    + .then to setup things to happen in sequence
    + can normally chain execution with .then()
      + only need to create a new context when
        + waiting on something unpredictable
        + OR MAYBE when doing multiple things
  - not sure about pushChild needing to 'resolve' the parent
    + think it's probably a yes
  - not sure about how to execute multiple things in sequence
  + not currently preserving eventContext across checkMetadata
    + that a bit is deliberately async-unsync
  + everything is stacking up on the eventQueue
    + seem to be resolving <unset:2> several times over
      + could be because 2 is everything's parent
  + problem is that we're stacking all the eventContexts in series
    + there are some that are event dependent
      + which means they can resolve at any time
        + which means the middle of the chain resolves
    + need to create contexts for each event-dependent event
      + then do some kind of aggregation to say 'wait for them all to finish'
    + eventContext:parent is used to kick the parent
    + eventContext:deps is used to store a list of all the contexts we depend on
      + everytime the parent gets kicked
        + it checks to see if all the deps have been satisfied
    + if there are no deps
      + it resolves right away
    + I get foggy on the different situations this can come up in
      1. do something in a child function, when it's done, allow its parent to be called
      2. ? is there a 2?

* add class nearvis
  + add to it 2x breadth on either side nearvis

* look over remaining eventContext vars

* need to expire unmatched scroll events
  + mouse wheel produces lots of scroll events
    + they hang around in the queue indefinitely
    + could expire after 1 second
      + because the gap between scroll and handler shouldn't be more than that

* think about buffering scroll events
  + handler_scroll
    buffer (function(){}, 50)
    + could return using a deferred
      + like a deferred, simple
        + but we have to be careful because 
          + there could be queued eventContexts interleaved with random scroll events
          + each one of those eventContexts needs to get dealt with
    + could return doing something clever with the invented context
      + could pushChild each context
        + so that once we complete the last one
        + we also complete all the others

* rebound/x-bound on 305 at fullscreen

* only show imgmetric when image has re-res'd

* smooth scrolling on trackpads
  + can't differentiate trackpad,
    + but can do smooth scrolling on variable
    + could make it an option

* synchronicity
  + waiting on all getImageMeta/metric pos to complete
    + before re-resing all
      + before updating
  + ideally want things to only aggregate at highest level
    + so that each thread can keep the pipefull
  + not important now

* refactor eventContext stuff
  + I'm not going to want to do it
    + but go back in, test alternatives and clean-up eventContext stuff
    + there are too many unanswered questions
      + and I'm sure I can make the syntax easier
  + started already
    + straight deferreds are the way to go
      + maybe just use eventQueue to handle the link between fire_ and handler_
  + question: how do we handle events we're trying to nullify
    + search 'replaceEvent'
      + refreshSelected / imageAdvanceTo 
  + question: should we sometimes resolve deferreds only after the handler fires?
    + like
      + fire_scrollUpdate
      + refreshSelected / imageAdvanceTo 
    + risky?
      + maybe
  + some contexts contain deferreds that are getting resolved
    + but the eventContext never gets removed from the eventQueue
      + while it's there it could potentially interfere with other queued eventContexts
      + need to remove them
        + try and use the eventQueue to resolve
          + because then the resolve can also remove from the queue
        + that requires that events can identify themselves to the queue
          + and say 'delete me'
        + best place to handle that is in hashTable
          + which means moving evid (eventQueue) to id (hashTable)
  + unfilled get requests are fine most of the time
    + they don't accumulate which is great
  + having some issues getting events to resolve all the way down the chain
    + try from api_ call and work backwards
      + carry on with this!
    + it is resolving, but only after 10s expiries

* optimise dragging in large image sets
  + implement vistable
  = it's very fast now

* refresh vistable on breadth/direction change

* viewing images fullscreen broken
  + suspect it's related to refreshing vistable
    + some work ok,
    - but not seq=0 or seq=1
  + no images are flagged as visible

* vis missing one image
  + /file/structured/tests/data/20-image_folder/#!seq=9
  + it's because we're hitting minref = maxref = ref 5
    + when ref 4 has the same value
      + need to always work backwards to be sure
    + needed a work forwards (like work backwards)

* nearvis isn't always right
  + in small image sets
    + good in large sets
  + need to remove nearvis
    + or rather rename nearvis once it's no longer near
  + better, but still too much nearvis in image_folder dataset

* too many visibles
  + seq=0 showing 8 & 9
    + should stop at 7
  + fixed with rounding = 3

* can scroll selected image off-screen
  + updates hash but doesn't update selected

* end, fullscreen, home
  + check re-res

* page up should eventually move the selection to 0
  + page down should eventually move to end

* imagemeta/ endpoint should always get image metadata
  + at the moment it only produces good metadata for pre-cached images
    + if we discover an image uncached
      + we should cache it at standard thumbnail size (longest edge 200)
        + most cache requests comes in 

* treat direction as another piece of hash state
  + where a hash value is the same as
    + NOT what's in document 
      + because it changes
    + the default value from the last page load

* res change needs to fresh metric positions
  + could tie that into refreshCells

* accelerate scroll catch-up
  + working but needs to be quicker
  + may need new async/promise trick

* home/end stalling
  + need to protect fire_hashUpdate
    + when firing will never trigger the handler_
      + i.e. home when at seq=0, end when at seq=last

* thinking about splitting the metadata store off from the mediacache
  + it's not without its complexities
  + the problem arises because we cache an image like thumbnail?maxlongest=200
    + I think it's reasonable to ask for image metadata for the same size
  + have found a workable solution for now
    = will delay decision for now

* border 4px on .cell a
  + once alignment is working

* cell resizing complexity
  + normalise heights at current width
    + work out proportion
      + that is the height at the point where this image becomes x-bound
    + trim the waste
      + leaves waste top and bottom
    + need a width which 
* need to refresh visTable only cellRefresh done

* introduce (!reloaded-width) data-ratio
  + updated everytime we load an image
    + loaded width is only updated the first time
  + addresses basic wobbles
--o--
* cells jigging about
  + gonna try not updated loaded-width
    = introduced ratio which stabilised them

* scrolling through directory is jumpy

* refreshCells is tricky
  + we really want to do it once
    + but at the moment we refresh each image (refreshImage)
      + and within that refresh its bounds
    + we need all the bounds back
      + to get the imageContainer sizes
        + to work out the free space around each
          + to average across a row/column
            + to resize the cells
              +++ to set the new cell sizes
                + to read back the new sizes
                  +++ to request the new resolutions
    + can't check bounds until all the images (thumbnails) have loaded
    + we will work through the images in order
      + but they'll load out of order
        + so we're going to struggle to get the rows
      + could break refreshImages into two phases

* need to wait for nearvis to be loaded
  + before trying to resize their cells
    + thinking about coupling all cellResizing to image loading
      + as soon as thumb loaded, it stays loaded
      + thumb loading
        + stores loaded-width
        + triggers attempt to resize cell
    + thinking about these things in cell singles/pairs/quads/octs
      + known as minorGroups
      + every load event checks its minorGroup
        + e.g. column for x-major, row for y-major
    + means that we're not formally doing a cellresize on all visibles any more
      + instead we do a resize on a single/pair/quad/oct because it becomes visible
  + this takes us back to hashTables
    + ideally want to preserve bucket information in visTable
      + and be able to update singles/pair/quad/oct (SPQO) easily
        + without having to rescan the whole lot
  + currently the whole vis chain works to a single set of functions
    + making this easier to change
  + however the resize event is important here
    + when we resize at 0
      + everything works beautifully
        + because there's no width change in anything prior (off-screen left)
    + when we resize at 500
      + everything jigs about horribly
    + we're trying to get to the point where
      1. resize @0 works
      2. scroll backwards and forwards works
      3. resize @500 works
    + that leads me to think
      + never change the width of an off-screen element prior (left or up)
        + that includes nearvis
      + probably keep processing cellresize in large batches of visible images
      + if we do have to adjust a prior cell width/height
        + always tweak scroll position to compensate
          + that's probably tricky to do surruptitiously
      + don't strip all previous width/heights
        + except on repaint event
          + and even then I'm not sure about it
      + series of fixes might be the best way to counter it

* forward scroll nearvis
  + if we try to cellresize on a cell without a thumb yet
    + it probably won't have a ratio
      + which returns a NaN problem
  + insert a getLoadedResolution and break second part into callbackfi
    + could make cellResize resolve a deferred
      + could make refreshImageResolution dependent on it
      + in fact should do that
        + but may still process 'nearvis' as async
        + leave as async
      + can make something async in one thread
        + and resync in another
          + the image loading lifts all boats

* big picture goal
  1. resize @0 works
  2. scroll backwards and forwards works
  3. resize @500 works

* forward scroll nearvis
  + shrinking visibles brings new 'nearvis' into view
    + need to make them visibles too
  + part of the process needs to expand the 'vis' selection
    + that also means expanding the nearvis selection

* vertical scroll doesn't work nicely yet
  + it's something comparatively simple
    = * instead of /
      + affected by alignment bug as per horizontal

* alias .sfun as this.containerName

* cell sizes jigging around
  + high seq numbers do 2 draws
    + first looks pretty good
      - but 2nd is weird
    + it's not the reresing
    + it's not resetting ratio
  = pretty sure it was a mixture of x-bound and y-bound

* changing breadth, direction, viewport size
  + needs to clear cell-specific percentages
    + then re-apply them

* even up border all the way around
  + actually important to cue which way the there's more content
  + margin-top: -8px lifts everything up
    + almost there, but we're not quite
    + right hand edge doesn't get thing
  + horizontal
    + need border on right hand edge
  + vertical
    + need border on bottom
  = don't worry about it for now
    + will have to insert an additional element

* chase down the NaNs
  + they're a lead
  + good debugging url mb@seq=288
    + debugging is hard
    + it's to do with an out-of-order execution (OOOE)
      + stepping through in a debugger doesn't find it

* perc's are not showing
  + but only for the latest batch of loads
    + old (but still visible) images lose their perc
    + it's because they're being left in a 'reresing' state

* introduce idea of partial visibility
  + sometimes we want the test to include 'partials'
    + e.g. 'visibles'
  + sometimes not
  + suggest we introduce 'partial'
    + rename nearvis as visnear
    + introduce vispart
    = it is now possible for there to be no 'visible' images
      + only vispart, but that's ok

* split structured.css from structuredfun.css

* reload on page with #!seq=0 (or just #!)
  - doesn't load images
    + seems to only load images if seq > 0

* reload on page with #!seq=0 (or just #!)
  - jumps to seq 5
  + even on mas it's doing to same thing (0->2)

* can't select seq for vispart
  + i.e. seq > visible

* vispart doesn't work on first two images

* jump straight to cell
  + e.g. seq=17
    + this is being killed by the scroll0,0 browser glitch
  + event order
    + handler_scrolled to #seq-17 (cells unresized)
    + handler_hashChanged seq=17
    + handler_scrolled to 0,0
    + handler_hashChanged seq=17 (doesn't see anything changed)
      + shouldn't do a refreshVisibility because we're looking at the wrong range
      + instead we need to make it realise seq has changed
        = done with a forceUpdate
  + at handler_scrolled to 0,0
    + need to default-out all the state
* a [breadth change] click seems to fire hash change seq=10
    + then fire hash change seq=10&breadth=1

* jump straight to cell for b1
  + e.g. breadth=1&seq=17
  = also fixed with forceUpdate

* high seq clicks (b2 to b1) jump back to seq 0
  + tricky
    + breadth change clears cell width/heights
      + which is good because we don't know where they're going to be
    + if we go to where seq 10 is now
      + the cellsResize will move it
        + so we end up seeing seq > 10
    + this also triggers hashChange trickle from seq=10 to seq=12
      + because 10 is only partly visible (vispart)
--o--
* can replicate exactly same issue
  + jump to high seq
    + then left arrow down through seqs
      + spacing whack
        + so we end up in the wrong place
  + need to work out exactly what's happening
    + because preseq images don't appear where I'd expect them
--o--
* develop a preseq spacer
  + as we're resizing cells to the left/above seq
    + insert a spacer at 0
      + then yank it out and move the scrollbar to compensate
  + a spacer may not work
    + because sometimes the preseqs are _wider_ than before
      + so we need a negative spacer
    + best done as a negative left/top on the ul.sfun
  = pretty good, bit of jitter but ok

* trigger redraw on offseq change

* scroll0,0 can arrive before or after scroll 32418
  + before is fine because it manually triggers handler_hashChanged again
  + after is a problem that means we render 0 instead of high seq
    + also the actually scroll to 0,0 can happen in the middle of our execution
  + need to capture the document scroll position at the same time as making the isVisible decision
    + not quite isvisible-time
  + seq106, 18851 + 839 = 19690
    = postponed, ordering not clear yet

* end key isn't returning at load completion
  + it's also jittering its way down from the last screen
  + seq 0 does now return properly

* nullify scroll0,0 not resolving at the time
  + it only gets cleaned up much later
    + can we resolve it as soon as it's nullified?
  + it's not that the nullified scroll0,0 event doesn't get resolved
    + it's that the nested handler_hashChanged event doesn't
  + there's an ordering issue
    + sometimes the scroll0,0 comes before
    + sometimes it comes after
  + this could be to do with the buffering of scroll events
    + we get a scroll0,0 and a real scroll very close together
    + try not buffering
      = have disabled buffering
  + parent (scroll0,0) is resolving before child (hash:seq208)
    + child effectively gets orphaned
      + but child is independent of parent
      + so it shouldn't matter
    + handler_hashChanged times out
      + profile every stage of the hashChanged
      + I think it's because we end up firing two hashChangeds with the same key!
      + doesn't seem to be an issue, but will follow
  + could repurpose event queue as list of all outstanding (unresolved) deferreds?
  + handler_hashChanged creates/picks up context
    + needs to pass it down to fire_scroll to get to handler_scrolled
      + I think that's why parenting is important
      + don't think we need to parent
      + because parent has a .done() waiting on the child
        + then parent will resolve itself
  + alsoRemove = false
    + that way we only remove things from the event queue once they're resolved
    + this is slightly more complicated
      + we sort of need two queues
        1 for unresolved events
        2 for unhandled events
          + these are fired events that have yet to be handled
          + we need them to be handled only once
            + but they may take a long time to get resolved
            = pending
    + make mergeOrPush look for an existing entry in the unhandled queue
      + this is worth doing
        + because at the moment two handlers can resolve the same single eventContext
          + leaving some contexts unresolved
          = come back to this
  + I think we're creating the 0,0 scroll events
    + example doesn't experience any 0,0 events
      + http://www.lightenna.com/staticpages/jsfiddle/hashseq/index.html#!seq=14
    + test: try and remove all the scrollTop calls for now
      + didn't make a difference
  = drowning in complexity, need to simplify

* build jsfiddle demo of basic setup
  + move fiddle to htdocs root
  + work out what causes the scroll0,0 event
    + vertical scroll fine
    + horizontal scroll fine
    + libraries ERROR
      - turns out it was the QUnit library

* it's time to tear out and refactor the hash changes
  + start by pulling out the init stuff
    + just attach the hash listener and see what it's like
    = works ok, but reload problematic
      + QUnit!

* new idea
  + always draw page-0
    + then jump up to page-X
  = abandoned for now

* straight jump from high-seq to low-seq (not reload)
  + seems like we're catching the position too late
  + or not locking the position early enough
  + there are two routes through a handler_hashChanged
    + setScrollPosition, which triggers other stuff
    + refreshVisibility
  + it's not the clearest split
    + really need to nail those two cases
      + and come up with a clearer definition of how they're different
  + test cases

    + cold load 0 = fine
      + handler_hashChanged(seq=0 or '') from init()
        + noChanges:refreshVisibility
          + setVisibleAll
          + refreshSelected

    + cold load low seq = fine
      1 handler_hashChanged(seq=6) from init()
        + seqChanged:setScrollPosition(931,0)
     2a handler_scrolled(0,0)
      3 handler_hashChanged(seq=6, forceUpdate)
     2b handler_scrolled(931,0)
      4 handler_scrolled_eventProcess(931)
        + images appear
      5 handler_scrolled(557)
      6 handler_scrolled_eventProcess(557)

    + cold load high seq = fine
      1 handler_hashChanged(seq=208) from init()
        + seqChanged:setScrollPosition(32418,0)
    [2a]handler_scrolled(0,0)
    [2b]handler_scrolled(32418,0)
      3 handler_hashChanged(seq=208, forceUpdate)
      2 handler_scrolled(32418,0)
      4 handler_scrolled_eventProcess(32418)
        + images appear
      5 handler_scrolled(31919,0), nullified
     10 nullify scroll0,0 setScrollPosition

    + load 0 skip low = fine
      + handler_hashChanged
      + handler_scrolled

    + load low skip high = workable problem

    + load high skip low = same workable problem
      1 handler_hashChanged(seq=6) from init()
        + seqChanged:setScrollPosition(931,0)
     2b handler_scrolled(931,0)
        + images appear
      3 handler_scrolled_eventProcess(931)

* turn off JS
  + work on no-js version
  + disable js all together to see what it looks like

* run tests from htdocs directory
  phpunit -c app/

* cached images not writing x-bound/y-bound
  + injectargs is injecting them too late
    + well after we've used getOrientation

* images with IPTC special whatsit create error

* alignment of menu icon

* make sfun header expand on hover using CSS-only in non-JS version
  + actually all the header actions require JS
    + so better not to show menu at all

* create hamburger icon for sfun header

* no-js or disabled-js
  + show all the thumbnails
  + no-js uses noscript alternative
  + disabled-js will have to manually flip them in
    + done in its own if clause

* cold load seq=1 doesn't draw anything
  + cold load seq=0 doing the same

* load of top-level container

* pass .selected in with range

* update vistable after cellsResize
      // update vistable
      // @todo should do this more selectively
      that.visTableMajor.updateAll(direction, $sfun_selectablecell);
      // use updated table to check visibles, but don't also tell then to reres yet
      that.setVisibleAll(false);

* need to check ratio (and therefore bounds) for range before calling flow_resizeCell
    for (var i = 0 ; i<bucket.length ; ++i) {
      var jqEnt = bucket[i];
      var jqBoundable = jqEnt.find('.boundable');
      if (jqBoundable.data('ratio') == undefined) {
        // wait for image to be loaded in order to get ratio
        defs[defs.length] = this.getLoadedResolution(jqEnt).done(function() {
          that.setBound(jqEnt);
        });
      }
    }

* split out layout engines
  + few options for how to implement these
    + using hooks
    + extend the sfun object
  + api is elegant and gives us abstraction
    + it's quite hard to split out cleanly
  + extend is good, but it keeps everything functional
    + which itself has issues
    + growing complexity of structured.js is a problem
      + proper abstraction is maybe a bit harder to code for
        + but it does give us a proper ADT
    + this is a pretty good way of developing an API architecture
      + I'll learn from that
    + API is a two way issue
      + we can move all the functions out into an object
        + and they need to be able to call out library functions in sfun
      + but we also need call points in
  + interesting question about pre and post activities
    + post update vistable makes sense
    + what about a pre-getLoadedResolution and setBound?
      + sort of yes
      + we don't want to have to load all the images
        + but it seems reasonable to ask a layout engine to layout cells
          + only when it knows what's in them
  + working, but need to finish parse of structured-flow.js
    + setBound
      + sorted
    + checking others

* compute ratio in html (using cache) if possible

* little bit of fun working on optimisation
  + reducing js load
    + Chrome profiling is most accurate

* directories in the middle of a set of images
  + breaks next image on to new major (row/column)
    + so following image ends up at 100% minor axis
  + could just push all sub-folders to the end
    + consistent with OS behaviours
  + also a chance to sort (ha!) non-images at head of directory

* disable flow for testing
  + resizepending never gets cleared
  = no longer gets set

* order
  + handler_hashChanged
    + [handler_scrolled]
  + refreshVisibility
  + setVisibleAll
    + loadThumbRefreshBounds
    + cellsResize
    + refreshImageResolution
* key points
  + cellResize has to have cell size and ratio only
    = have multi-streamed
      + now runs at same time as loading the thumbs

* blurring of first two images in HP set
  + this is to do with the execution order
    + when the thumbnails are cached
      + ratio gets loaded by the html
    + we do a cellsResize
    + not sure why that loads some very low-res thumbnails
      + [viewport] resize is fine
    + only seems to be the first load
      + and only then of cached images
    + doesn't seem to happen when we pause in debugger
      + suspect we're reresing before the thumbnail loads
  + it's not the first two images
    + it's the portrait images
      + because the cell height is tiny (35px) before image loaded into it
    + try suspending the bound
      - nope, same deal
  + there's a tension between cellsResize and loaded-width
    + the point of pushing loaded-width and ratio out in the html
      + is to make the page loading faster
    + if we have to wait for the thumb to load
      + in order to decide if we should reres
      + we might as well not push the loaded-res out with the html
    + we can still send the native-res
      + which means we won't have to do a imagemeta api call

* detect whether visible boundaries have changed at all
  + use to decide if cellsResize should go on to call reres
  + crude optimisation, but effective

* folder images are loaded before everything else
  + they're currently loaded with src
    + use desrc instead
  + may need another class or
    + need to consider how we currently select images for desrc->src'ing
  + aiming for same recursive structure
  + work on bounding

* make flow resize directories first
  + then stick the crucial details on the outer li
    + e.g. ratio
  + so that the main resize will correctly proportion the cell
  + set the ratio on the parent
  + can't take the ratio from the ul
    + because it's expand-to-fit
  + need to take it off the actual images

* test removing width:100% from flow-pc > .cell a
  + seems to bring the whole image back in view
  + sort of fine but it creates some alignment issues under flow layout
    + could be caused by flow not calculating widths/heights allowing for margin
      + creates case where dimensions are off slightly
      + which is why part of each image gets lost

* experiment with direction=y
  + direction-y is broken
    + it's loading all the images
  + all images are getting set visible
  + simple to start with
    + not setting flow-y on html

* images above (in direction=y) are being given visnear
  + but should show be vispart
  + setVisibleAll
    + vispart works forward, but not backwards
    + need to backtrack through previous visnear to find ones that are vispart

* vispart on first load
  + showing up as vispart images not reresing
  + think this might have been the vis problem
    + stowing for now, will recreate if rediscovered as an issue

* margin problem
  + margins + 100% create cropped images
--o--
* losing a bit of the image
  + shows up as mc yellow border missing
  + also pink highlighter gets lost on bottom/right edges
  + related to margins
  = margins looking great
    + flow layout will need work to accommodate

* adapt flow layout to new calc'd margins
  + alley set properly too

* experiment with alternative breadths
  + broadly ok
    + breadth 1 has a shuffle
    + no
      + there is a shuffle, but it's unrelated
  + 2 and 4 tested fine

* offseq breaks preseq fix
  = re-test
    + seems fine
    + chrome issue is separable

* re-enabling buffering doesn't work
  + it doesn't load any images
    = fixed, bad name

* little optimisation cycle
  + concentrate on scroll and click
    + refreshMetric

* all cells are broadly the same size
  + so after one cell has upped its resolution
    + we should remember that and use it as the default thumbnail size
    + which should mean we can skip refreshResolution
  = worked really nicely

* image thumbs are loaded by two means
  + setting an image as visible loads it thumb (always)
    + I suspect we should only do it for visible/vispart
      + that way we can delay visnear to later (refreshImageSet)
      + by which time we may have set lastMaxLongest
        + which means visnear images get the correct size right away
  + refreshImageSet loads the thumbs
    + but it does it better
    + by doing it for the visibles first

* scroll:x=4 for first image
  + because first cell now lives at 4px
  + best to allow for the -4px

* need to somehow store the function that we will execute in the actOnEvent clause

* when we resolve an event
  + see if it has a parent
    + if it has, make that the criticalSection
    + if not, make criticalSection = null

--o--
Example 1: created by entering seq=20 url into new tab
o unfilled get request for key[hash:seq=20] structured.js:2114
+ pushed event context[undefined:hash:seq=20, pending, invented context for handler_hashChanged], qlen now 1 structured.js:2012
> entering critical section for undefined:hash:seq=20, pending, invented context for handler_hashChanged structured.js:2195
+ pushed event context[undefined:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate], qlen now 2 structured.js:2012
* fired scroll event 1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate structured.js:2373
- pulled event context[1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate], q2 structured.js:2112
 - pulled not invented context[1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled], q2 structured.js:2146
  + pushed event[undefined:hash:seq=20, pending, invented context for handler_hashChanged] has parent[1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps] structured.js:2096
_ delaying critical section for 1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps structured.js:2207

--o--
Example 3: created by entering seq=20 url into new tab
o unfilled get request for key[hash:seq=20] structured.js:2115
+ pushed event context[undefined:hash:seq=20, pending, invented context for handler_hashChanged], qlen now 1 structured.js:2013
> entering critical section for undefined:hash:seq=20, pending, invented context for handler_hashChanged structured.js:2198
- deprecated event context[undefined:hash:seq=20, pending, invented context for handler_hashChanged] in favour of [see next pushed], q0 structured.js:2045
+ pushed event context[undefined:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged], qlen now 1 structured.js:2013
* fired scroll event 1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged structured.js:2376
- pulled event context[1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged], q1 structured.js:2113
 - pulled not invented context[1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged, instead of invented context for handler_scrolled], q1 structured.js:2147
  + pushed event[undefined:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged, 1 deps] has parent[1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged, instead of invented context for handler_scrolled, 1 deps] structured.js:2097
_ delaying critical section for 1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged, instead of invented context for handler_scrolled, 1 deps structured.js:2210
     - it's parenting itself
       + which creates a stall
       + this makes sense
         + because we're in the handler_hash critical section
           + then we fire a scroll with the same context
           + when the scroll event comes through
             + it has the handler context
             + but goes through the same actOnEvent logic
               + which at the moment only sees the critical section
               = now have a detection in place to guard against this

* criticalsection code is currently [!commented] buggy
  + we get into problems when a handler_scroll is a child of a handler_hash
    + the handler_hash is waiting on the scroll
      + but we're stopping the scroll from resolving because handler_hash is in its critical section
--o--
Example 2: created by reloading (seq=20) while scrolling somewhere else
  i.e. refresh means browser fires a scrollevent for new page (e.g. scroll:x=3239) that's different from where we should be (e.g. scroll:x=3590)
--o--
o unfilled get request for key[hash:seq=20] structured.js:2115
+ pushed event context[undefined:hash:seq=20, pending, invented context for handler_hashChanged], qlen now 1 structured.js:2013
> entering critical section for undefined:hash:seq=20, pending, invented context for handler_hashChanged structured.js:2198
- deprecated event context[undefined:hash:seq=20, pending, invented context for handler_hashChanged] in favour of [see next pushed], q0 structured.js:2045
+ pushed event context[undefined:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged], qlen now 1 structured.js:2013
* fired scroll event 1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged structured.js:2381
+ pushed event context[undefined:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate], qlen now 2 structured.js:2013
* fired scroll event 2:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate structured.js:2381
- pulled event context[2:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate], q2 structured.js:2113
 - pulled not invented context[2:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled], q2 structured.js:2147
  + pushed event[undefined:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged] has parent[2:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps] structured.js:2097
_ delaying critical section for 2:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps structured.js:2215
+ pushed event context[undefined:scroll:x=1484&y=0, pending, localContext for fire_scrollUpdate], qlen now 3 structured.js:2013
* fired scroll event 3:scroll:x=1484&y=0, pending, localContext for fire_scrollUpdate structured.js:2381
- pulled event context[3:scroll:x=1484&y=0, pending, localContext for fire_scrollUpdate], q3 structured.js:2113
 - pulled not invented context[3:scroll:x=1484&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled], q3 structured.js:2147
  + pushed event[2:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps] has parent[3:scroll:x=1484&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps] structured.js:2097
_ delaying critical section for 3:scroll:x=1484&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps structured.js:2215
      + this looks like it's being caused by fire_scrollUpdate
        + that's probably scroll events coming before the handler_hash has finished
          + suggest we delay listening for scroll events until we've resolved the first handler_hash
        + now this may create issues
          + because we currently rely on the scroll handler to reposition the viewport
          + that's important when we do an Example-2-style scroll-refresh
            + or an Example-1-style initial load
        = implemented manual call

* make test suite work by dynamically including QUnit
  + then move on to eventQueue test
  = QUnit load is currently commented, because it triggers a scroll:x=0&y=0 (0,0)
    + uncommented, but delayed load until click
    = that worked incredibly well

* double loading
  + it may be related to scroll bug
    + it was for seq=0
    - but not for seq>0
  + definitely doing 2 sets of loads
    + verified in chrome
      + we do one set of loads as part of the handler_hash
      + and another as part of handler_scroll
        + this happens because Chrome sends a scroll event back to where it was before
    + firefox is harder
      + inserting breakpoints changes the way it works
      + need to prove this
        + insert console.log statements
          + to track the start of each handler_
      = proved
--o--
* critical section
  + this speaks to a wider issue of handlers firing in the middle of other handlers
    + or in parallel
  + might need to protect the handlers so they can't run at the same time
    + good opportunity to improve and extend buffer()
    + single queue shared between both handlers
      + stick everything on it
        + investigate priming events with 'donotwait'
          + so we don't introduce a universal 250ms delay
    + could use eventQueue
      + it is a queue (ordered list)
      + we've got push, could create pop
      - it's not how it works at the moment
        + the handlers_ pop by referencing a key
          + we're talking about making the handlers queue stuff
        + now they kind of do that already
          + because they create a local context
      + could setup deps
        + to make the new event dependent on the existing event one
      + the current status
        + all events get pushed on to the queue
      + the change
        + setup one event as 'currently-in-progress'
          + inCriticalSection flag on eventContext
            + use actOnEvent function as opportunity to flag it
        + modify push
          + if another eventContext is inCriticalSection
            + flag the current event as 'do-not-act'
            + make the current event dependent on the one inCriticalSection (crit-dep)
      + change seems pretty simple
        + need to understand interaction with buffer()
        + will end up adding a lot of crit-deps that simply resolve
          + but that should be ok
            + can always come back to it later
            + besides, that what we do already in handler_scrolled
    + eventQueue child -> completes -> kicks parent
      + currently can only cope with a single parent
        + if we allow multiple parents
          + we can use the existing mechanism
      + this is actually a little more complicated
        + we need to end up with a queue
          + so it's not as simple as just making all events parents of the critical
          + we need to chain them
          + this needs its own test
    + actOnContext is the right place for it
      + but there are a few different drivers
        + actOnContext needs to return true/false
        + not sure if actOnContext should resolve the deferred
          + or whether the calling function (handler_) should
          = the latter
            + it's more consistent
          + therefore return true or false
    + tricky bug may be hiding
      + if we setup replaceEvent to resolve itself
        + what happens when another event merges with it?
        = coded against it

* test whole test suite
  + work's remarkably well
    + really nearly there for iteration #1!
  + trigger key press is returning a deferred
    + but it isn't waiting long enough for the scroll event to complete
      + probably no bundling up child events
      + firefox illustrates it nicely using endkey dirty test
        + shows the right cells
          - but they haven't been rendered (no thumbs/reres/imgmetric)
      + the event log is very complicated
        + many events are getting merged
          + and somehow one it getting resolved too early
      + best way to fix it is to write the eventQueue test

* debug vistable test

* cheeky vertical scrollbar
  + sorted with calc() again

* write eventQueue test
  + need to test child resolving kicks parents
  + this needs to be thorough
    + there's now a lot of complexity in there

* test replaceEvent scenarios

* test actOnContext

* setBound on nearvis [async] after doing everything else
  + may need to disable caching to test it
    + because at the moment we push bound out with the HTML
  + can't be sure, but it looks like we're setting it already
  = investigate in really large image set (MB)
  - don't appear to be loading nearvis at all
    + we are actually loading the images
      + but we don't seem to be swapping them in
  = little bit messy
    + for visible images
      + we load the thumbnail when they're given their visible/vispart class
    + for visnear images
      + we load the thumbnail in a slightly gorky part-of waitLoadedGetResolution
      + better to do it all on the class
        + if we can do it async
  = may return to this, but not now

* border missing from directories

* merging a context leaves two nearly identical event contexts on the stack
  + makes for some confusing debugging messages
    + need to decide if pushOrMerge should remove old objects from the stack
      + I think it should
    + but how do we handle its deferred
      + can't resolve
      + want to move things hanging on it over to new item
  + merge is a bit of a mess
    + we leave things hanging on the old deferred
    + not currently updating critical section
  + neater to just pull new attributes into old context
    = done that
  + however there are subtleties
    + when merging a context
      + we take over its key
    + that means that future attempts to pull by the old key will fail
      + which means new contexts get invented when they shouldn't
  + there are a few options
    + don't merge
      + just parent
        + resolving the child will kick the parent
    + merge
      + but keep all the old keys
        + key:object becomes N:1
          + not 1:N, so never multiple objects under 1 key
        + this doesn't work with our current keyarr
  + what is the essence of a merge?
    + it's only called in a fire_ type scenario
      + which is the bridge function to a handler_
    + I'm leaning towards parent
      + merge is quite destructive
        + we're losing granularity
        + parent preserves more information
          + also resolves are clearer when there's parenting
      + keep merge function the way it is
        + might be useful for other things
        + but write a new parent version and replace in fire_ family
  + not sure about auto-resolve for parents
    + they should sort of resolve themselves
      + because everything else does
    + going to take it out for now
      + might reprise it later
    + I think the only reason not to auto-resolve
      + is that the parent might need to do something first
        + if the child resolves the parent
          + that means the parent's resolved before it's completed its stuff
          = finally, everything auto-resolves
            + removed autoresolve flag
            + no necessary as also introduced eventContext.action
      + each context could have a function (func) queued
        + so that when it's ready to work
          + it can execute that function
          + then resolve itself
            + it's logical
            + up to now we've been limited to managing 'func' inside actOnContext
              + because we could be delaying it
              + that's means we've had to have the func promises in that function
                + which was messy when we tried to unify all the context resolvers
            + by putting it in a context.variable
              + we can call it anywhere
                + which allows us to move all the resolution to a single function
                  + which makes debugging and tracking easier
      + not sure about that
        + all the contexts tend to get resolved in their handlers at the moment
          + actOnContext sets a good direction of travel
        + all the wrapUp is now done in the eventQueue
          + the handler functions don't wrapUp any more
  + this is all becoming clearer
  + parenting is good

* need to bind to scroll earlier than completion of handler_hash
  + handler_hash only resolved when all nearvis loaded
    + when is the earliest we could accept scroll events
      - hard to tell
        + it's when the browser has given us the first scroll event
          + if it's going to give us it!
      + but we could rely on the critical section
        + probably safe to bind once handler_hash is in its critical section

* sfun is an image collection tool
  + for people who collect and organise images

* get eventQueue emptying out properly
  + buffered scroll events die in the queue
  + resolve can always take something out of the queue
    + fallback
  + introduce a new 3rd list to track 'unfilled' contexts
    + fill list?
      + unhandled
    + new subtle issue
      + if we match against unhandled
        + getOrInvent will now invent a new context
      + need to do a clever thing in getOrInvent
        + get matches it using the keyarr list
          + but if the corresponding entry in unhandled is null
            + that means we're already processing this event
            + and it hasn't yet been resolved
            + so don't process it again
    + unhandled array may be a chance to get rid of criticalSection?
      + maybe not
      + criticalSection covers case where an [unfired] scroll event starts processing in the middle of a hash event
  + major variable renaming
    + all local
      + apart from static, which I can live with
    + much more consistent now

* end key test not completing in proper time
  + can't actually select end entity if it's a directory
    + selection bounces back from 10 to 9

* images getting stuck in reresing
  + waiting for timeout before completing
    + suspect it's a critical section/delaying bug

* scrolling suddenly jerks back
  + then forward again after check expiries
    + set a break point on check expiries
--o--
* thinking about re-writing bufer
  + making it implicit
    + hash:seqs are queue up on the stack
      + when we've got a new one
        + there's really no value in going to the old one
        + might as well dump it
          + have to be a little bit careful of parents
            + this hash:seq could be part of a long chain
            + I think we're just going to resolve() it
              + which handles parent
                + just need to check it doesn't have children
                + which it can't because it hasn't run yet
                  + no critical_section delayed children
                  + no fired events downstream
    + this is exactly the same for the scrolls
      + we basically just want to resolve them to
        + which is what we do in buffer
  + nice to do it for everything
    + we need some mechanism of identifying similar events
      + suggest key up to first :
      + could always later come back and define families
  * actOnContext seems to be the place for vetting events
    + need to understand how we're currently delaying them
      + they seem to be getting lost because
        + they are children of refreshSelected events
          + that resolve without them [async]
        + I think we fire another fireHashUpdate so quickly
          + that the browser never processes the original hash:seq
          - no, that's not correct
        + browser does catch it
          + but we use 'replaceEvent' in place
            + which I guess nulls it and doesn't resolve it
    + idea 1: stop doing that
      + find out why we're replaceEventing and not resolving
    + idea 2: give hash:seqs an expire
      + so that checkExpiries tidies them up
  + 1 it's because in parent() we're giving children the replaceEvent
    + of their parents
      + so the parent just gets resolved
        + maybe replace replaceEvent with a flag
          + nullify
  + considering shift to resolve all contexts as part of the actOnContext
    + yes
    + change actOnContext first
      + then progressively remove the wrapUp functions
        + testing all the way
    + done
--o--
  + re-introduce buffering for [scroll] events
    + should apply to all events
      + to discard an event
        + we just remove it from the unhandled queue
        + need to be a bit careful of parents
          + they need resolving when the peer gets resolved
          + actually buffer() just resolved them instantly
            + we can do that
            + but let them hang around in 2q (not unhandled)
              + so that if a handler gets them 
                + we spin right past
    + in actOnContext
      + search list for event key root (e.g. hash: or scroll:)
        + find all events that aren't in their critical_section
  + can't do buffering until we resolve _why_ the skipping is happening
    + can't replicate that right now
      + I think shelve this for now

* work on test suite
  + need to redo eventQueue tests
    + actOnContext now resolves its own contexts

* work on test suite
  + need to check that api_keypress is really waiting until its resolved
    + properly, all the way through to completion of sub-contexts
      + as we need the hash to have completed
        + to have selected the right image
  + first 'click' event comes through jQuery
    + not sfun
      + so no mechanism to wait for done() right now
  + very close now
    + having some good complete runs

* introduce progressive scroll test
  + scroll to middle
  + check that we have > 1000px + viewport headroom
  + fire 100 x 10px scroll events in sequence
    + check that the final one gets resolved
      + check that position of browser after final event

* introduce re-res of nearvis
  + only if last_max_longest is null
    + because that's the only time we see a flash of low-res images
  + when reres is false
    + we load the low-res/thumb
  + when reres is true
    + we don't seem to load the image at all
    = seems to be solved by bracketing

* scroll lock-up
  + especially when scrolling back from high seq
    + I think we get queued up
      + then we resolve all the elements in that queue
        - simultaneously
        + which means that the processor gets slammed
          + and that stops us queuing up new events
    + can we try dumping all the events
      + instead of executing them
    + I think it's the slew of done()s
  + also got scroll events getting lost
    + and tidied up by checkExpiries
    + could be related
      + might as well tidy those up anyway
        + they all seem to be coming from fireScrollUpdate
        + directly from mouseWheeled
    + these are hard problems
    + for now
      + press on with dumping to lower load

* it's all got too complicated
  + I'm trying to track down a scroll event bug
    + let's document it here
  + start by thinking about where selected should get resolved
    + it's a context
      + so should get resolved with all the contexts
  + change out contextGetResolver to use .always()
    = done
  + move context resolver parent thing
    = everything resolved in contextAttachResolver -> resolve
  + basic load stack
      hash:seq=250
        scroll:x=23000
          scroll completes
        scroll resolved 
      hash resolved
  + basic scroll
      scroll:x=23000
        scroll completes
      scroll resolved
  + basic scroll and select next
      scroll:x=23000
        selected:seq=96
          hash:seq=96
            hash completes
          hash resolved
        selected resolved
      scroll resolved

* unhandled starts out with too many nulls
  + I would expect it to look almost exactly like keyarr
    + bear in mind that null just means its gone through actOnContext

* arrow keys not working

* end key test leads to infinite loop
  + need to nullify action
    + otherwise
    + A enters critical section
      + A fires B
        + B processes
        + B completes
        + B resolve sees A as parent
          + B's resolution calls A again
    = action = null works well

* replace unhandled with action reference instead
  + can't use action because action means it's been processed (action function called)
  + handled means that it's been through a handler_ function
    + moved handled to eventContext
    + got rid of unhandled array

* request for seq=last leads to infinite loop that breaks chrome

* rapid scroll is a great test
  + nicely illustrates delaying
    + worth coaxing that test to be as hard as possible
  + shows a couple of things
    1 selected events never get resolved
      + they only get cleaned up by checkExpiries
        + they are async
          + so they're not holding anything up
          + but they can be resolved earlier
        + should resolve on replaceEvent
        + looks like replaceEvent functions aren't resolving their parents
          = now they do
    2 scroll is currently sticky
      + it's not currently jumping out of order
        + at least not on this computer
      + but it's not smooth
      + looking at the logs
        + there are heaps of queued scroll events
          + that all get resolved at the end
          + I think they could all get dumped
            + my only worry is that dumping might hide other problems
        = ok, tested on larger, slower image set
      + but let's work on selectively dropping events
        + 3rd queue seems to be the way to do it
          + that means deciding what to drop in getOrInvent
      + say there are many rapid [scroll] events
        + A B C D E F G H
      + dump by removing from unhandled array
      + 2-deep dumping algorithm
        + we catch A
          + start processing it
        + B gets queued
        + C gets queued
          + dump B
        ...
        + H gets queued
          + dump G
      + dumping is a little more complicated
        + when dumping B
          + C needs to get parented to A
      + getOrInvent is tricky
        + by the time we get the call from getOrInvent
          + the event has already been fired by the browser
        + we've got a very short space of time to decide if we're going to decide
          + to process, queue (by parenting) or nullify (by returning null)
        + there's got to be a sort of 3rd way here
          + when we're processing C (in getOrInvent)
            + we're going into the A-B parenting relationship
              + already setup in actOnContext
            + and unpicking it
        + getOrInvent pulls matching element from eventQueue
          + or creates it
            + so think 'C'
          + at the time we see 'C' we don't know if we're going to queue it (parent it)
            + because we're just inventing it or pulling it from the eventQueue
          + alternative time to do dumping is when we queue
            + which makes it part of actOnContext
            + we're getting towards the idea of two kinds of 'parent'
              + real parents
                + where the parent spawned the child event
              + execution order parents
                + where the parent needs to be executed when the child completes
            + we generally use it in the second context
          + the only time this comes up is when we process a torrent of events
            + we end up with a very unrealistic chain of unrelated events
              + the only interesting thing is we do it in the opposite direction
              1 handlerHash -> fireScroll
                + sets up scroll event as child of handlerHash
              2 actOnEvent B, while executing A
                + sets up B as a _parent_ of A
                  + so that when A completes, B gets kicked
              + these two things shouldn't be in the same queue
                + 1 should be chains of events
                  + using the existing mechanism
                + 2 should be some kind of macro level thing
                  + like a straight-forward list at the eventQueue object level
              + how much do we re-write now
                + I think first thing is to test the effectiveness of dumping events
                + I'm also not sure that we really want to split these into two queues
                  + the intersection between those queues requires management
          + events go through a few key stages
            + getOrInvent, simple single events, no deps
              + they don't get handled until after actOnContext
            + actOnContext, some processing done but no downstream events
              + safe to make parents of current critical_section
                + can hunt for similar peers

* transfer rapid scroll test to all

* fun optimise
  + visTable.updateAll
    + called a lot
    + change updateAll to updateRange
      + need to index by ref
        + could create a special dedicated index
        + or just use the ref
          + ref fits better

* fun optimise
  + get offsetWidth (jquery) called from refreshMetric and setBound
    + use standard test
    = not important now

* could pursue buffer() for speed
  + we're processing too much during a scroll
    + stick a delayUntil on a context
  + everytime we put an event into its critical section
    + we want to check for and resolve redundant events
      + do that first, then do delay
  = deprecated by event dumping

* look at .find calls

* check that we only start doing stuff on nearvis AFTER we've done everything on visible/vispart
  + there's a short delay then it seems like nothing is happening
    + I suspect it's because we're doing nearvis

* loading seq=high shows a tiny slice of the previous cell
  + happens for direction-x/y
  + even at offseq=0 (default)
  = almost sorted
    + just need to tweak the rounding so that we don't include vispart
      + where the near edge of the cell is actually offscreen (0 to -5)

* cold load seq=high jumps in Chrome only
  + something to do with the final stage
    + from container offset to scroll
  + there's a difference in the cell widths between hash->setScroll and scrollHandler
    + I suspect
      + we're collapsing it somehow
      + or chrome is collapsing it
    + verify by
      + checking fiddle
        + doesn't seem to happen
      + jquery checking the cell widths
        + seem fine
      + F10ing through things it does in between
  + start by disabling flow
    + see if this occurs with just the basic layout
  + gaining some insight into this
    + it looks like (without flow) cmd+r reloads the page
      + and triggers a scroll event to return to the same place in the document

* loading near far edge with lots of directories
  - introduces shuffle
    + and events go mad

* start with pc, but set cell sizes using px after that
  + otherwise we get very strange effects during resize (at high seq)

* eventually capture -8px margin on #sfun
  + before changing it to realign major
    + so that when we apply new value (to realign the major axis)
    + it includes the -8px
      + otherwise we show a little edge
  + not sure if this is necessary or not

* scrolling backwards beyond visnear
  + jumps forward to show selected
    = try just buffering

* rewrite test logic, just document here
    + cold load 0
    + cold load low seq
    + cold load high seq
    + load 0 skip low
    + load low skip high
    + load high skip low

* jumping to seq creates different results to reloading to seq
  + like before, seq gets kicked right by preseq images loading

* re-enable scroll buffering

* staged scroll should go row-by-row or column-by-column
  + also centre using offseq=centre
    + a number should preserve the number of scroll
      + but centre is more meaningful

* use offseq to maintain the relative position of the current seq image
  + fun to watch it grow and shrink

* sfun button needs to go into the corner
  + been pushed out by some padding/margin

* end event is resolving slowly
  + only after 10s expiry
  + it's getting lost during a scroll update
    + we know because it's a scroll:x=1799 event that expires
      + which triggers the original keyPress to resolve
  + the disconnect seems to be happening
    + because we try and scroll to 1799
    + but the scrollEvent that comes back is only to 720
      + could solve by estimating position of window near END
      + better to solve with wildcards
    + need to create an eventContext really early
      + at the point where we fire_keyPress(key_END)
      + that eventContext needs to be passed all the way through
      + and contain a wildcard
        + to connect with ambiguous scroll-to-end
        + now that's actually quite hard
          + the event changes nature with each pass of the batton
          + we're basically saying
            + when you fire a scrollUpdate for this,
              + call it something else
            + that's not an easy narrative
    + alternative is to soften the link between all fired scroll events
      + and the handlers that immediately follow them
    + or some combination of the two
      + something in the master eventContext
        + that says soften the following
          + temp issue: not timing out old events
    + alternative might be to try and more accurately guess
      + where scroll event will actually go to
        + i.e. document end - screen width
      + could do that as a simple max on the fire_scrollUpdate
        + that's pretty close
          + still having to expiry it though
            + let's look at context id to see which contexts are missing
      + it's clear that one of the images isn't resolving
        + when I force the deferred to resolve, everything is fine
--o--
* wire in deferreds through everything else
  + make it work for handler_hash first
--o--
* extend test suite
  + test reres
    + end
  + need to connect the deferred in the hash handler to some kind of external/api
    + pushing a value in the URL might be an option
      + but that only extends to hash values
      + nice to come up with something global
        + need to find a way to push identifiers through the event chain
          + e.g. x in scrollUpdate(x) -> handler_scrolled(x)
--o--
* end test has errors
  + some images have been reloaded
    + it's because we're resolving the scroll event after the metadata has been returned
      - not after the reres has completed
    + I can see cases where we might want both of those
      + but for now, concentrate on the images loading

* directories as full cell multi-image panes
  + basically like little microcosms of the whole screen
    + play with a border to make them look different

* selector doesn't show on two sides
  + need to show all the way around the selected image

* extend test suite once all current tests are working
  + test reres
    + mouse wheel two images right
  + test imgmetric vis

* visTable bugs
  + fairly minor stuff I think
    + use test suite to debug

* sfun icon
  + think about the glassbar concept
    + pushing out from the icon

* shiny menu bar

* play with image overlays
  + couple of possible routes
    + python to opencv to imagemeta
  + image augmentation database
    + at the point of serving up an image
      + look for more metadata in central DB
        + annotate the image that's returned to the browser
        + look at options for pulling metadata directly from image using JS

* remember dimensions of last resize
  + and somehow tag onto cell
    + so that we don't have to resize cells that we've already resized
--o--
* remember dimensions of last reres
  + and somehow tag onto cell
    + so that we're not constantly asking images to reres unnecessarily

* checkExpiries crucial for resolution of rapid scroll (in all)
  + suspect something's not getting resolved that should be
  + also rapid scroll takes a really long time (15s)
    + it seems to hang at the end for a long time
      + with no events firing
--o--
* lots of events getting stacked up in queue and not resolving
  + when scrolling, it's lots of scroll events
    + these are dumped events
  + we need to set expiry when we dump them

* research video coding
ffmpeg.exe -i <src> -b:v 1500k -vcodec libx264 -g 30 -movflags +faststart <output>.mp4

* use rapid scroll test to show that
  + the last scroll event is fired and handled
    = done
  + some events are getting dumped
    + tricky test
    + probably need to expose something new in the API to find out
      + maintain dump count
        + sample before and after

* images not invisible until loaded
  + showing image file name
    + sorted out by flow

* might need a rethink on scrolling
  + out-of-order mouse wheels
    + could queue relative seq changes
      + e.g. +1/-1
  + slow also extends to scroll events
    + whenever we start seriously process scroll events
      + the browser gets all jerky
  + I think they should use vistable
    + and just advance the scroll by a certain amount
      + then we just focus on the scroll problem
      = works well
  + now combine that with some buffering on scroll events
    + works really fast
  + buffering & dumping together
    + creates issues for test suite
      + I imagine we're dropping some events that we shouldn't be
        + so some contexts never get resolved
    + it's complex
      + I don't like the idea of doing both
  + let's see how quickly we can look up the eventContext
    + if that's viable to do on every event
      + then at least we can be clearer about what we're chucking out when buffering
    = that worked
  + test suite resolves
    + 0 events get dumped
      + because of the buffering
        + event dumping doesn't seem important for now
          + but it does work so might be important in the future
        + might just leave it in the code
          + but uncalled
        = have marked call as deprecated
    = test suite green

* mouseWheel needs to keep track of where the last event should have got to
  + because if we buffer the scroll
    + and don't actually scroll
    + then use the current (non-scrolled) position for offsetting future scroll events
      + the mouseWheel doesn't move far enough
  + but how to store position between calls?
    + pulling from event queue is messy
      + because we've got to findRegex, then pull out coord
    + static's looking pretty good
  + this could be a good time to scroll one row at a time
    + that way we're just incrementing a seq counter
      + and pushing a hash: seq instead of a scroll
    + seems like a good change to make
      = done
    + still same issue about caching position
      + could maybe use getSeq
        + some kind of setSeq command
          + or straight to its static
        + I'm not sure of the ramifications of that
          + because the event could get dumped
        + probably fine, so long as when the event gets processed it sets the same variable
          + so we're only potentially out of whack for a fraction of a second
  + this might get solved by shortcutting
    - it didn't
  + back to static approach
    + this is a sequence number
      + so we want the last hash seq that was requested
        + not necessarily yet set/resolved (e.g. called setSeq)
      + can we manually poke a value into the static in getSeq?
    = found a better way
  + it's faster for mouseWheel to use visTable to find the next image position
    + and just scroll to that place (instantly)
      + the scroll handler will catch up

* go slow through this bit
  + accuracy and reliability is crucial for further dev
--o--
* shortcutting event firing
  + rather than changing hash, then waiting for the handler to fire
    + we could (in certain cases)
    + create the eventContext
      + then manually fire the handler
    + probably should only do if there's nothing on the queue
      + could make that part of the fire_
    = code written
  + needs a proper timed test
  + this is less pressing now
    + because scrolling is buffered
      + and mouseWheel is direct

* mousewheel getting delayed while images loading
  + must never delay the mousewheel
    + delay shows up even better with flow on

* nicer alignment
  + if image is entirely visible in the viewport, adjust offseq
  + if image isn't visible, scroll as little as possible to make it visible
    = postponed
      + this isn't as relevant now
        + because the selection just finds its place after a scroll/wheel

* mousewheel after scroll needs to re-align
  + otherwise can be scrolling in half-images

* extend vistable tests to cover updateRange
  + creating vistable and partial

* load correct-res shortcut not working
  + it is working
    + it's just that the nearvis image loads
      + are somehow still using the thumb res
      + it was nearvis
    + insert into test suite
  = working
* write test to check that correct-res shorcut is working

* chrome wheel event problem
  + everything else is fine (scroll, reload)
    + firefox is fine
  + replicable in firefox in some circumstances
    + I suspect it's related to position rounding
  = rounding error

* upgraded Windows to php 5.6.1
  + using built-in optimizer now
  + need to reinstall PEAR and PHPUnit
    + in structuredfun-pc/structured/vendor/php/
wget http://pear.php.net/go-pear.phar
php go-pear.phar
  + turns out we don't really need pear
    + uninstalled
  + setup phpunit as composer dep
    "require-dev": {
        "phpunit/phpunit": "4.2.*",
    }
  + trying composer.phar in bin
    + run cmdonly.bat to get environment
php ..\bin\composer.phar self-update
    - fails with php-5.6-asssociated cert error
      + manually downloaded using
        curl -sS https://getcomposer.org/installer | php -- --cafile=cacert.pem
          - failed
        wget https://getcomposer.org/installer
        php installer
          + worked
php ..\bin\composer.phar update

* gzip everything out of apache to make it pop

* scroll going the wrong way for image snap vertical

* keypress to change between horiz and vert

* flow
  + when we resize a range of cells
    + when affect all the cells above it too
      + need to increment their vistable (key) position
  + don't really want to duplicate key in both keyarr and obj
    + because it makes updating it messy
      + can't think of a consistent way of avoiding that
  + for now leave it duplicated and shift both in keyShift()

* fix failing test
  + 'reres of last page of images'
    + failing only sometimes in on folders with nested folders (at the end)
      + fails in both Firefox and Chrome, so not a browser thing
  + failed with flow on/off

* when we do infinite scroll
  + do it properly with pages as part of the URL
    + i.e. not in the hashbang
  + #! works really well for visualisation state

* plus and minus to zoom in and out

* shares on elan
  + some access issues, probably vhost related
    + don't try to solve
    + just verify for later
  = no it's fine
--o--
* get family photos on elan

* speed
  + I think Apache performs much the same for Windows/Linux
  + it looks like PHP is slower
    + could be file loading/processing
    + could be Symfony spin-up
    + compare times for main HTML load
      + it's about 4x quicker on Linux
        + 800ms on Windows (PHP 5.6)
        + 200ms on Linux (PHP 5.3, Zend Server)
    + shows up in the image loads too
  + leave this for now
    + doesn't seem to be anything obvious
  = found realpath_cache_size
    + big performance jump
      + difference down to 2x
    + images now less than 100ms each

* performance is fun, features are fun
  + but the only thing stopping this being released is bugs
    + keep focussed on first release of MLP

* thinking about maximising the space
  + could swap an image +/-1 to get it to the top of a column
  + landscape
    + could expand the width of a cell
    + could decrease the height of a cell
  + portrait
    + could expand the height of a cell
    + could decrease the width of a cell
  = flow

* mouse wheel up is going up in pairs
  + could be a simple LTE/GTE thing
    + ha! it's relates
    + LTE makes it go down in pairs
    + GTE makes it go up in pairs
--o--
* change direction doesn't seem to update the vistable
  + it needs to do a complete refresh
    + I think this because mouse wheel up on vertical doesn't align
  + taken out rounding
    + it's not necessary

* can't wheel back up when direction y (image snap)
  + it was a rounding problem
    + now using the same style of code as getVisibleBoundaries
    + but not the same function
      + because we treat the rounding differently
      + it's direction-dependent for handlerMouseWheeled

* flow, cell x-margin is too great
  + means that the grid doesn't quite align properly
    + this is because the cells are slightly too wide
    + the height includes a margin (4px, gutter)
      + that needs to be subtracted
      + before we calculate the width

* single image (b=1,d=y) given vispart
  + means there are no visible images
    + so no selection can be applied
      + so no hash seq change
    = sorted using fallback to vispart

* vertical scrolling
  + can't scroll down
    + when b=2,4,8
    + works fine when b=1
  = works now we have square grids
--o--
* all of these could be related to getBreadth
  + for vertical scrolling
    + breadth doesn't really equal breadth
  + might be worth doing an experiment with pure square cells
    + 1x1, 2x2, 4x4
    + instead of current
      + 1x1, 4x2, 8x4
--o--
* vistable clear is getting called, but it's not clear how we get out of alignment
  + when we change from x to y (or v.v.)
    + the URL stops getting updated
  + turns out there's a simpler problem to solve first
    1 reload page
    2 switch from horizontal to vertical
      = get two scrollbars, which is wrong
    3 wiggle mouse over redundant scrollbar
      = leaps to wrong part of new page
    + in Firefox
      + looks like selected isn't being updated
--o--
* mouse wheel back trips up
  + not just under flow
  + but then gets itself sorted out when going forward again
    + it's to do with scrolling back to a place before the cell resizes
      + either because its size changes (flow)
      + or because it gets an image (no-flow)

* can get into a mode where nothing's happening
  + because something got left on the queue
    - isn't yet resolved
  + and is delaying everything after it
    + resolve by watching checkExpiries
  + something completes
    + and doesn't kick its parent
    + the critical section is null
      + might be good to track last critical section
  + event parenting order
  1126:keypress:k13
    1127:hash:b4
      1128:scroll:x0y0
  + could be a result of dumping the wrong things
    + we dump 1119:hash:
      + which is the last_critical_section at checkExpiries
  + I think we have to say which events are dumpable
    + can dump repeated scrolls
    + can dump repeated hash seqs
    + but can't dump some hash seqs because they're clicks
      + and change the state
    = introduced selecting dumping
  + test suite errors persist, hard to debug concurrency
  + looks like a blockage introduced by having
    + two scroll:x=0&y=0 events on the queue at the same time
      + they both have the effect of sending the browser back to 0
      + but only one can get found by handlerScrolled
        + so only one gets resolved
        + leaving the other one orphaned
      + verify that's what's happening
  + couple of solutions
    1 in handlerScrolled
      + look for _all_ matching events
        + process
        + then resolve them all
    2 in fireScrollUpdate
      + check to see if we've got a pending update to this scroll position
        + staple our colours to the existing one
    + leaning towards 2 because 1 has the risk of cascading
  = working nicely now
    + 3 successful test suite runs
      + leaving it at this point
    + seems to run consistently in Chrome
  = test in firefox
  + still happens occassionally but it's much more complicated than it was
    + which is actually a good thing
      + because most cases work fine
      + there are just a few that trip it up
    + this is getting more and more rare
      + hardly encountered at all today
        = put on ice for now

* resize event when viewing at b1
  + http://10.12.1.120:8097/file/family/0000uk_stuff_photos/#!breadth=1&seq=70

* IE console error

* can we change #! to # or #/
  + working towards a nice consistent url structure
    = not simple and not important for now

* need a little bit of jQuery animation on imagesnap scroll
  + it's very hard to tell what's happened with our images

* animation for envision seq too
  = not straight forward

* feature: think about pink border
  + in full-screen mode it's just a big annoying reminder of a slow load
    + dropping from fullscreen

* IE alignment
http://stackoverflow.com/questions/16811716/height100-not-working-in-internet-explorer
  = sorted with height:100% up the chain

* Firefox ignores calc directive on height
  + it means that cells are always full height
    + so a 4x4 grid is actually only 4x1
  + AMAZINGLY this has been fixed by the IE alignment work!

* there are some really nice behaviours that come from not resizing cells
  + no flow
  + such as being able to resize the screen
    + and still see the same set of images

* final two images cropped as visnear
  + should be at least vispart
    + not consistent for test all
      + final two images seem fine as vispart before and after test
    + pretty consistent for test
      + arranged with just enough tests to make it hit bottom
        + firefox on its own is fine
        + firefox + firebug
          + hits bottom and throws error
        + chrome is just the same with a small-height window
  + mock up single test
    + with large 0-div to force right-hand-edge scrollbar
    = mocked up
  + pretty sure that final image is partially off-screen
    + which is bouncing the selected seq back from 253 to 246
    + this is backed up by Chrome analysis
  + this seems to be a discontinuity
    + between visTableMajor and the actual cells on the page
      + visTableMajor thinks the final cell is at 80640
      + the actual cell is at 79569
        + why?
      + it's the vertical scrollbar
        + when it gets introduced, we lost 16px
        + and that's 16px off every 1280
      + let's not cache viewportMajor
        + but cache the jQuery yardstick instead
    + at some point after the scroll
      + the cells all shift
        + why?
      + QUnit again
        + this time because of its fixture
      = just needed a vistable refresh

* imagecreatefromstring is stumbling over gif
  + look at AE

* a broken image in the chain
  + breaks everything downstream of it
  + need to be robust to failure
    = haven't fixed this one, come back to it later

* need to get an alpha online
  + doesn't need to be a big release, but it does have to be a first release
  + we don't have to promote it much
    + but having something out is vital
  + after _something_ is out
    + I can start managing the 'but I only get 1 shot' misbelief

* gzip'ing image content

* page up/down needs to be based on viewport pages
  + can't rely on jumping a certain number of images forward/back
    + because they could be really narrow/fat
    + flow makes images different widths
  + event getting stuck
    + suspect it's the NaN on the minor axis
  + test with flow
  = works

* scroll doesn't work on a mac
  + gets as far as +2 (seq=2 -> seq=4)
    + then doesn't seem to fire any events
--o--
* apple scroll is too fast
  + log the scroll events
    + research way of detecting apple trackpad
    + worst case we read the OS from the browser string and assume
  + look at scroll event frequency
    + might be able to reduce speed by limiting the reach of each scroll
--o--
* check apple sideways scroll
  + magic mouse has nice feature for 2D scrolling
    + need to make it work simply and easily
  + complicated by grabbing y-scroll events

* detect trackpad, but allow override
  + catch ontouchstart
    + set imagesnap to false
  + detect mac, guess-work but a reasonable starting point

* preventDefault on downward scroll with imagesnap

* make page up/down animate like mouseWheel
  + stop page up/down animating if fullscreen
    + all the other fullscreen ops just pop

* angle brackets [ ] in directory names
    + because we use them for escaping substitutes

* bad image spoils directory
  + does need to be robust
    + just found a second occurence of a bad image
  + this is because we wait for all the thumbnails to load (collectively)
    + before triggering load of hires

* dots (.) in directory names, like mq
  + works fine in pulling out images for folder thumbnail

* test first package
  = worked well!

* next time we package
  + revise instructions below
  + check there's no extra shares
  + check we don't need to actually clear down unnecessary files
    + clear Apache logs
    + clear Apache manual
    + clear zips
    + clear structured/htdocs/tests/data
    + clear data

* flush bug list
  - there's useful stuff in there for searching

* delete Apache2 manual from repo

* delete data design
Design thoughts while coding Structuredfun

Process for pulling a thumbnail
Get file metadata
Derive cachekey
Is file in cache?
  Yes, return
Is it video?
  Is full res in cache
    Yes, pass back to image_obj to subsample to thumbnail, return
  Pull full res from video
  Store in cache
  Treat as image
Is it image
  Subsample
  Return

url substitution
  comes up for shares
  comes up for get nth image
can't mess with url
  - because that's really the same 
  + convenient because everything else is downstream
let's do it on a filename level

* clicking between folders
  + should preserve some hashbang state
    + direction/breadth
    - not seq
  + something really nice about loading a folder
    + that looks exactly like its thumbnail
  + hmm, could make the thumbnail views also 4x4
    + no point, they're small already

* Safari mobile loading all images on refresh
  + all images flagged as vispart
    + which I think is why they're getting loaded
    - not consistent
  = not frequently occuring enough to block release

* outdated
  + disable debug in javascript

* package instructions
  + check release number e.g. 0.9.3
  + do a clean clone of git repo
    + or update packaging-only repo
      + need to do a submodule update too
  + copy folder
  + check opcache settings at bottom of file
    + refresh is at 60s, not 2s for debugging
opcache.revalidate_freq=60
  + clean unnecessary files
    + clean zips
\structuredfun-pc-v0p9p3\structured\vendor\zips
    + clean .gitignore, .gitmodules
    + clean .git
    + clean LICENSE
    + clean README.md
  + package (zip) without a top-level dir
  + expand and run test suites

--- first launch: it's not a big deal ---

* setup basic demo folder locally
  + fill with Wikimedia images

* bug: error image in folder thumbnails
  + falling outside of the bounds of the folder
    + it's a missing y-bound on the image thumbnail
      + perhaps because the dimensions of the error image
      + don't match the error image
    + when substituting the error image need to reload width and height

* bug: fix missing images in wikimedia folder
  + seems to be caused by non-standard characters in filenames
    + if the name contains illegal characters
    + can refer to it by its place in the directory
      + because PHP will still open it

* bug: crazy ????-??? image in Russian
  + start by printing character codes
  + too difficult to solve
    + I think just ignore the problem for now
    + flagged with a @todo

* feature: imgmetric needs to line up with the corner of the image
  + and fade out
  + and show on hover

* feature: maintain mean ratio in js as we load images

* create an additional flow-X class using createCSSSelector
http://stackoverflow.com/questions/1720320/how-to-dynamically-create-css-class-in-javascript-and-apply
  + use it to tweak the major axis cell size
  + not sure if we want a different class for each flow?
    + could just stick it was width in .flow-pc > .cell
      + and update each time setBreadth called
  + class should be self contained because createCSSSelector overwrites all its CSS
    + &.flow-dynamic-major > .cell
  + probably do want to guess at ratio when rendering html
    + can simply pull ratio in init() where it's available
  + there's a lot to 

* imgmetric showing up middle-left on landscape images
  + I'm going to call it a feature!

* feature: separate flow-x name from grid resolution
  + read cell size using some kind of gutterball (gridball)
    + actually couldn't we just use a cell?
      + if they're all the same size it shouldn't matter which
      + getCellSize function is fine
        + but will rename major
  + struggling to remember the places where we use this
    + page up and down
      + nope
    + wheel up and down
      + nope
  + only place seems to be the test suite
    + vis non-vis simple assumes the first image to display will be seq8

* turn requirements.txt into INSTALL.md
  + use that file to document issues

* work out SELinux steps and document in INSTALL.md
  + it's probably an semanage to httpd_sys_content_t && restorecon

* test write permission nicely
  + fail with a decent error
Warning: mkdir(): Permission denied in /var/www/git/github.com/structuredfun-linux/structured/htdocs/src/Lightenna/StructuredBundle/DependencyInjection/CachedMetadataFileReader.php on line 30

* bug: flow-pc changing
  + changing either
    + breadth
    + direction
  + needs to refresh it
  + resize event is covered by the hashchanged(force)

* bug: need to make new flow-pc work vertical
  = lovely bit of calculation

* could use hover to select an image
  + makes sense to keep the seq updated
    = works, but there's a slightly complex side effect
    + selecting an image tries to move it to offseq=0
      + so we end up scrolling
  + two ways to approach this
    1 relax scrolling so if the image is in view, we don't scroll
    2 implement offseq properly
  + let's investigate 2
    + offseq works very very well
    + intuitive, fast
      + reloads to exactly the same place
    - destroyed by infinite recursion
      - triggered by scroll
  + wierd thing where if you set an offseq involving a .
    + it drops the # from the first #!
    + means all offseqs need to be integers

* clicking to see an image fullscreen
  + should centre the offseq
    + but that's a tricky op
    + because it's centre of the viewport - half the cell width
      + infact harder than that
  + the cell changes size when it goes full screen
    + we don't know exactly how big it will be
      + that's hard to guess beforehand
        + even if we can guess accurately based on
          + mean cell width for b = 1
        + it may not be that size if we run flow
      + one problem at a time
        + we can guess now
        + and that gets us through the night
          + so let's just do that for now
          + and review later when/if it becomes a problem
    + not sure that's possible
      + getCellMajor pulls it from DOM
    + is possible
      + done using same algorithm that compute we cell width percentage
  + might be able to set offseq=centre
    + then dynamically replace that at scroll-time
    + really want offseq to be a number

* oval focus overlay
  + keep it subtle

* centring in vertical mode
  + click image to make it go fullscreen

* make theme part of the hash state

* margin is uneven top and bottom in flow-2 (and probably -4/-8)
  + 4px at the top and 8px at the bottom
    + seems to be the height - 4px on .page .content
  + can't simply remove height: 100% - 4px
    + because it causes a scrollbar right

* expand fullscreen to edges
  + needed to make cell tinting look right

* need some kind of cell tile colouring (tinting)
  + crucial to explain why the borders all look so different
    + otherwise the alignment just feel sketchy
  + calling this 'tinting'
    + many complications
      + probably need some kind of clever HTML class to apply it
    + outer border needs aligning to cell tint too
  + trying only on flow-1 for now

* hover selecting boxes is a bit too much
--o-- (hopefully)
* debug nasty interaction between offseq and scroll
  + we get into some game-ending recursion
  + seems to happen when we're in Firebug

* profile: switching back and forth between fullscreen and tile view
  + it's very sluggish on large image sets
    + not clear results
    + chrome says it's mainly idle
    + firefox hints at
      + 300ms redoing metric positions
      + 100ms updating visTable
  + nothing obvious for now

* could add an alternator li in for the current flow
  + or even one for all flows
    + doesn't really solve the problem
  + adding just for current flow requires js
    + keen to avoid that
      + because we might as well just do manual colouring in js
      + if we're going to do that

* quick profile and optimise load
  + we're doing a lot more now
    + nothing obvious from resize or scroll or init/reload
      + it's the same old stuff
      + lot of time spent idle (loading images)
        + would do better to split the stages
  + can wait until after first release

* rejig this list
  + more important to get to a first release

* dvb1 needs work
  + it's making sensible decisions
    + but it really needs to try to show the images as big as possible
  + in fact that's really true of all the vertical displays

* when receiving image metadata by js /imagemeta call
  + set to DOM for hover
    + take out GHOTI
    + strip extension

* write clever defaults thing
  + don't want to show a metadata value if it's just the default
    + e.g. Author unknown

* work on metadata display
  + MVP to display wikimedia images online
--o--
* if caption set, use caption instead of filename
  + put caption on a single image using Photoshop
    + check that caption gets put on cached copies

* set sfun_version in cache
  + formalise stats->meta into its own class
    + give its fields default values if not set
  + set sfun_version
  + could load its own metadata
  + could save metadata changes
    + can always request filename stuff from parent (MetadataFileReader)
  + I think unserialize() will cope with that so long as we serialize() it that way
    + actually another reason for giving it its own class
  + pretty broken at the moment
    + not even setting metadata to cached images
  + right, now at least saving it properly
    + need to pull metadata
      + all looking pretty good now
  + need to embed correct stuff in HTML
    + we're doing it for js version, now we need to populate it properly from HTML
      + where cached
  + check first stage
    + read correctly from file
      + dump metadata from original source file
    + file to cached thumbnail
      + not there yet
    + working well
      + display more metadata (copyright, keywords and source)

* metadata flow
  + original image -> loses it to cache
  + cache -> loses it to browser (saved)
  + focus on first stage first
    + preserve existing metadata between original image and cache
      http://10.12.1.120:8097/image/playspace/wikimedia-gallery1/Squirrel_posing_meta.jpg~args&thumb=true&maxwidth=1000&maxheight=
    + cache key
      d00f6b283a8bf3abe022d338761785a9.dat
  + seems like we're just not reading it properly
    + we're only reading out that which we serialized in
    + which is useless for real images
      + it's good for cache images, but not for real ones

* lost title on space shuttle

* need to be able to set metadata
  + photoshop can't do it without re-writing the file
  + hunt around for a tool
    + worst case write into sfun
    = pull that feature forward

* only my squirrel has proper metadata at the moment

* load metadata in HTML

* bug in display of metadata
  + we're displaying some defaults

* maybe refactor video thumbnail metadata
  + good to get it all into the same class

* change cache encoding from hash to escape
  + symmetry with mod_rewrite unescape
    + also helps me see what's going on in file names
  + at this stage, don't try and be clever with attributes
    + that's for later
  - turns out this is not simple
    + md5 does a great job of dealing with chars that Windows won't allow in filenames
  - also all kinds of problems doing path substitutions
    + escaping would only work for local files within the document root
    - not shares

* create VideoMetadata
  + make sure VideoMetadata gets written through into all thumbnails by the cache
    + currently first video (fullres) thumbnail is good
      + but derivatives are all just Metadata
    + it's lost somewhere in filterImage
  + when we do anything to the metadata up in the controller
    + we should set it back to the mfr
    + so any writes out of the mfr
      + do it with the right metadata
  + IptcWriter is now only used by Metadata.php to write out metadata
    + which is way more sensible

* merge Metadata and IptcWriter
  + should be a single class
    + for now it's a subclass which is fine

* feature exploration: dynamic video thumbnails
  + percentage frames from ffmpeg is tricky
    + need to know the length of the video
      + that's a good thing to have in metadata anyway
  + get length in frames to js via metadata
    + js being sent all metadata in imagemeta
      + think about getting metadata (entire json object) into $img()
  + use length to calculate request in frames
  + what we want is a micro trailer
    + 10x1s snips from the first third of the clip
  + swap out image
  + it's ok, but not a home run
    + it doesn't give that much information
    + the scan left-right operation doesn't really add value
      + scan could be good for thumb selection
        + but it needs to be much faster
          + perhaps we could generate all partition images in one go
          + then scan would be instantaneous
  = resume later

* change out call to getOrientation 
  + it's misleading to call it getOrientation
    + also don't pass back orientation
  + maybe call for video too
    + good continuity

* re-run test suite
  + check ok after all these changes
  + just one failure which has been there for ages
    + test broken because now we push files to the end of the directory view
    + maybe should just leave them in order
      + directories too?
    + no, I like them being at the end

* condense certain metadata fields into icons
  + copyright, keywords, source

* nice message for no-read directories
  + when linux can't access a folder
    + we currently get an error message
  + sorted
    + now says File Not Found which is ok

* feature: use proper symbols for c p s k
  + &copy; for copyright
  + installed open source font (ionicons)

* not sure if we need left-right margins on fullscreen
  - stuff photos look all joined up
  + might work if every cell had a tint
    + e.g. background +#111111 and background -#111111
  + also will want to put lines down the middle of the gutter
    + think about orange strips on Kodak negs
    + not sure how to do that while preserving cell shades
      + maybe just say that's not possible with shaded cells
  + start with plain vanilla cell margin left-right
    + looks good
  + tint every cell (above and below the background)
  + settled on tinting in a single direction

* vertical cell height on fullscreen
  + needs same gap that shows on verical left-right

* none of the cell widths are working
  + I suspect because my &.flow-x takes priority
    + verified
  + need to rejig the css
    + done nicely using extra selector

* page up and down should scroll exactly x cell widths
  + 1 when at fullscreen
    + basically want to make sure we show each partial image
      + in its entirety when paging

* zero offseq when moving to horizontal scrolling
  + it's actually not always zero
    + depends on the breadth
      + it'll be zero for b1
    + but at b2 we need to centre
      + so good to centre on a switchover
  + nicely done, needs testing
    = seems good

* feature: grey the icons with more information

* create metadata type (using Metadata.php)
http://codemonkeys.be/2013/01/ajaxify-your-symfony2-forms-with-jquery/

* fix editable bug
    + weird $this->editable bug
      + I think it's serialization
        + old serialized objects wouldn't have the field

* edit icon needs to work in js-only
  + current depends on html (cached images)

* add metadata editable flag to windows settings
  + clear mediacache

* I _think_ we can set height on meta to auto
  + which means that the metadata can fill the box nicely
    + very useful for the form
  + need to test that assumption in a few browsers
    + try chrome
  - loses background
    + try min-height: 50%;
  + works
  + happy accident that the metadata form pops up to 50%

* make vertical the default scroll direction
  + it's just what people are used to

* bug: darkening is no longer showing up under meta
  + just needed height back

* bug: something is connecting to cloudfront
  + GET https://d3ijcis4e2ziok.cloudfront.net/tpc-check.html net::ERR_TIMED_OUT 
  + which really messes up my loads when offline/nearly offline
    + I suspect it's just google
    + actually it's buffer

* metadata position
  + I wonder if we should put metadata in the middle of the image
  + it's not perfect at the moment
    + after all it crosses over the border of the image
  + could be centre
    + could be top
  + leave it where it is for now
    + think I've found a solution to the fadey background problem

* bug: javascript error on processing imagemeta read request

* modes design
  + thinking about some kind of global mode flag
    + relevant for key handler (arrows on metadata edit)
    + but applies across everything
      + global event model
    + shared events
      + click on image (fullscreen or select)
      + keypress
      + hover over image
  + break clickfull into 'tool'
    + separate js file
  + break metadata-edit into tool
  + switching between tools deactivates certain listeners
    + sounds like an API activate/deactivate call
  + master
    + there are some events that shouldn't be delegated
      + e.g. alt-up
  + shares
    + some tools might want to share some behaviour
    + e.g. clickfull and select
      + both want to use arrow-left/right to change selection
    + leaning towards event trees
      + that allows sharing
        + each node has the option of acting and/or delegating
  + it would be nice to prove the concept before investing in this
    + but it is a good clean-up op
      + this is just like all the PPO-SSO-CSO work on wito2
      + it's dangerous by virtue of its scale of aspiration
        + we've created so much already that needs more testing/debugging
  + complicated by eventQueue
    + need to return a deferred
      + that means that we need to aggregate all the children deferreds
        + at every level in the tree
        + which means children
          + another parent-child relationship
  + currently we have parent to indicate peer to call on resolution
    + can we use that same mechanism to handle children
  + for now, just keep it simple
    + single master acts like a fallback
      + tools can grab an event
        + need a name
    + need to go simpler than that
      + because otherwise we'll implement an interim solution
        + that's both complicated and needs rewriting
    + it's worth really thinking about this
      + it's a potential time sink
    + how about just
      + all active tools get notified of all events
        + return deferreds
      + that works pretty well
        + just means we don't handle 'both/either/or'
          + metadata-edit deactivates clickfull
            + ideally we want it to be simple
            + to move events up or down the tree in the future
        + duplicating down is fine
          + it's a comparatively small amount of code in the event handler
            + ideally don't want to have to duplicate all the actual doer functions
              + tools could contribute to a function pool
    + this plan is laced with complexities
      + loads of useful functions are within the structured.js closure
        + e.g. $img()
        + have added api call

* retest flow
  + made a few api changes
  + worth checking they haven't broken anything
  + all seems ok
    + flow is so beautiful
      + I'm always struck by it each time I turn it on
      + worth persevering with it

* try and factor out [at least some of] clickfull
  + into clickfull tool
    + that's such an interesting illustration
      + toggleFullscreen is full of library calls
    + it is doable externally
      + moved toggleFullscreen
      + now move all the calls
    + leaning towards notify all
      + let listeners be smart about what they react to
        + can always do activate/deactivate later
        + can always do event cascades/trees later too
  + don't use true/false to preventDefault
    + pass down the event
      + let anyone squash it

* break metadata-editing out into its own module

* think about exclusivity
  + the only requirement at the moment is that we
    + can disable navigator module
  + start with simple preventDefault event preventing

* tool ordering if going to be important
  + we need everything to be higher than navigator
    + well
      + we need metaedit to be higher than navigator
    + the order we include the js in should do it

* break navigator into its own module
  + just include the things that we'll want to turn off
  + actually leave it all in main
    + because we can disable it using a simple prevent
  + and we'll want to use navigator across multiple modules

* can't use preventDefault
  + as suspected
  + because we sometimes need to actually execute the default handler
    + but ignore our own receivers
    + e.g. arrow keys
  + add a simple attribute to the event
    + because it's a controlled environment
    + no need to confuse with jitter
      + which is actually called litter
  + change in language
    + prevent (preventDefault) stops js from processing
    + inactive (sfun_active = false) stops other tools from processing

* chase down breakthrough return
  + caused by mde-cf script ordering
    = solved

* feature: IPTC editing
  + should be turn-offable in settings
    + but on by default
  + useful to set IPTC Source/licence
  + probably have to pull this up
    + because we don't have anything that can edit IPTC nicely
  + use nice ion edit icon (ion-compose or icon-edit)
    + switch to compose because it's bigger (more clickable)
  + javascript to pull form into shape on edit
    + better than testing raw form because we don't break images
    + detect clicks on spans
  + setup form handler within imagemeta route
    + handleRequest seems to update the object
    + just need to write back to file
  + transparent, 100% width, hide labels
  + clicks on form elements
  + got basic form working being rendered
    + stop all fields being mandatory
  + update button in full width box
  + max width the box at 400px
    + don't need full width for big screens/images
  + put form down to bottom of pane as per .meta
  + alignment of editable form fields
  + problem putting forms inside clickable <a> tags
    + need to bubble up to put caret into correct place in form field
    + can't bubble all the way up because otherwise we click into image
      + try moving the form outside into the cell
    + works outside cell
  + fadey thing on back of metaform-holder too
    + leave the span showing!
  + set caret to headline when first editing metadata
  + arrow keys
    + disable keypress listener altogether
      + or just silence using flag
    + quite like to use keys to change between form fields
      + down or tab to change to next field
  + hover over edit icon
    + should go read to show there's an action

* plugin metadata editing form
  + make button just take you back to the same page
    + little bit of graceful degradation
      + takes you to the top of the folder
      + but that's not the end of the world
  + capture click
    + ajax submit form data
    + data-action on form doesn't really make sense
      + might as well put something on image
        + that's where all the other data is
        + for now could just use meta-src
    + we want to process the metadata that comes back
      + applying it back to the fields
        + allows the user to validate their edit
        + and see any server-side correction we've done

* strip arguments off meta-src
  + I don't think we need the args
    + seems ok
    + clear media cache test
  + imagemeta doesn't work
    + will reintroduce args to see if that's it
      + yeap
    + the reason it's problematic is
    + image/... requests the image
      + loads source
      + caches, with metadata
    + imagemeta/... then loads from cache
      + without args
        + imagemeta never matches the image
  + there's no problem in pushing metadata with arguments
    + but I'm got to do something a bit clever server-side
      + to find
  = leave args on meta-src

* show metadata only on hover over .meta span

* apply metadata to fields
  + needs to actually put response back into fields
    + post is coming back with changes
    + but they're getting lost
      + not showing up in the field
  = because data was coming back as a string, now json

* think about server-side flow
  + maybe
  + it almost doesn't matter if we don't update the cell ratios in js
    + the first load will be right
    + resize events are unusual
  + minor axis is always 100%
  + major axis could be > or < the guide
    + say 25% could be 22% or 35%
  + for simplicity
    + we want those major axis widths to even out
      + that only happens if
        + there's roughly the same number of
          + portrait and landscape images
    + actually we don't want it to even out
    + it doesn't need to be true to the guide (25%)
  + it just needs to be true to a mean
    + all the images can be 80% high
      + so long as they all come out like that over a window
      + the exact definition of the window is flexible
        + I like 4 rows/columns
          + but we can parameterise that
  + first run still needs to be js
    + that means js needs to be reliable
      + implement the 4-col means in js

* metadata being saved to file
  + but that file doesn't appear again when I reload
  + shouldn't be saving it in files anyway
    + let's save it the original only
  + then implement doctrine-sqlite for metadata caching


* store metadata on POST
  + store in original image
    + store in all cached copies
      + finding those cached copies is hard
      + it makes a metadata update an expensive write
      + might be better to
        + write to original
        + dump cached copies
        + regen current-size cached image
          + i.e. the one currently being used
        + regen 200px version
      + revise given that we need to keep args
        + write to current
        + return
          + continue work in separate thread maybe
        + write to original
        + find and dump all cached copies except current
  + keep it simple to start with
    + just write to the image variant we've named in the args
      + that's always maxlongest=200
        + hmmm, not sure about that
    + anyway, just updating local is good enough
      + that means that the metadata will atleast persist after an edit
  + could always load the 200
    + process would be that we
      + get metadata from the 200 (if it's in the cache), else
      + get metadata from the original
    + if we have lots of metadata in lots of cache files
      + we end up with a caching problem
        + lots of copies of the data that all need invalidating
      + really want to get the metadata out of the image files!
        + but there are advantages to having it there
          + like if someone right-click-downloads an image
            + it has its metadata in it
      + we're slowly shifting towards a DB model
        + the source image files still are the authoritative source for metadata
        + but the metadata cache could/should be a DB
      + is there a simple DB built into PHP?
        + yes, SQLite
      + makes sense to write metadata into an SQLite instance
        + keep the image file 'pure'
        + also means we don't depend on the 200px image
          + we can still load the right image first time
          + because the SQLite DB will have the sizes
        + also means we can implement flow server-side!
    + right, that's a big change
      + but it's the right one
        + doctrine, symfony2, sqlite

* setup sqlite and doctrine
  + may not use it immediately
  + but good to do

* create database if it doesn't exist already
$schemaTool = new \Doctrine\ORM\Tools\SchemaTool($entityManager);
$classes = $entityManager->getMetadataFactory()->getAllMetadata();
$schemaTool->createSchema($classes);

* run php test suite
  = solid

* rename metadata fields
  + can rename them so let's do that first

* try and make all metadata fields protected
  + good setup for merging into ImageMetadata class
  + can't make them protected
    + without breaking the form api
  + protected is the right way to do it
    + could try and make the ImageMetadata fields public
      + but that's just bad programming
  + check that they serialize when protected
  + biggest barrier seems to be protected -> twig
    + I think I need to return them as an array
  + right, getting closer now
    + we can get the values into twig
    + but if they're not public values
      + we need to do something clever with the assignment
        + x = y = z
  + sorted

* first run
  + need to align js tag handling
  + looks like meta is being sent empty {}
  + sorted
    + using a JSON copy

* try and setup a doctrine custom entity type
  + look at bootstrap.php
    + seems not to exist
    + instead there's bootstrap.php.cache

* merge ImageMetadata class with Metadata.php
  + that's a very good candidate now
    + field names work
    + protected fields
  + try and use entity in rest of program first
    + seems good

* understand how inheriting entities work in doctrine-managed DBs
  + pretty simple
http://doctrine-orm.readthedocs.org/en/latest/reference/inheritance-mapping.html

* get original filename into ImageMetadata
  + needs to be in there anyway as 

* rename width and height as original_width, original_height
  + consistent

* not posting description (iptc_caption)
  + it's just not in the form post
    + the field is there
    + but it's empty ('Untitled')

* clear cache
  + I suspect we have been updating the original images
    + but it's not showing up
    + because we don't refresh the cached copy
  = clear cache does show metadata

* store metadata in original image
  + means that we can probably push the IPTC editing stuff out
    + maybe even push the doctrine-sqlite work out
  + got to get to a first release
  + it is being stored

* implement hash and dehash
  + can't always rely on symmetry
  + may have done this already
  + working out how hashing/dehashing is done
    + I think we implement hash-only at the moment
      + raw name gets hashed
      + then we look for that hash key in the mediacache folder
  + that way we never need a dehash

* bug: js test suite doesn't work direction=x
  + even with 2 bad tests removed
    + there are other broken ones
    + could be something to do with the wikimedia image set
      + try with others
  + phew!
    + worked once we fixed a missing original_ for height

* Change 'Copyright unknown' to 'Copyright remains with author'

* Change 'Author unknown' to blank
  + when we're loading images for the first time, it's misleading
    + could say "Loading metadata"
    + could say "Searching for author information"
    + Author pending

* go through wikimedia images
  + add metadata properly
    + verify in sfun
      + or fallback to photoshop
      - photoshop requires a recompression of the image
    - windows just makes a mess
  ++ surprisingly difficult to find a windows tool that doesn't mess it up!
  + apply correct metadata to images
    + verify in photoshop

* move icons to follow byline

* image %age size label
  + nice if we could make them all appear in the same place

* show image metric with 'Reresing...' message whilst loading

* make metric default position be middle-left

* turn off wrap-around on scroll
  + it's actually confusing
    + take it out
    + shows up in fullscreen and left/right

* basic demo with Wikimedia images
  + look at overall experience, start to finish
    + good enough
    + not perfect but fine

* horiz scrolling in 2x or 4x views
  + wheel only goes in one direction

* videos being rendered with timecode=
  + gives internal server error

* circle back to dark theme variants for image meta

* use padding instead of margin to ensure consistent left gap
  + makes symbols look nice(ish) when they wrap

* don't show author if not known
  + still showing on first load

* folder titles
  + style metadata overlay to be permanent

* enable extension=php_fileinfo.dll for structuredfun-linux
  + test if it's actually necessary
    + maybe only Windows throws an error
PHP.ini configuration
---------------------
Note to self:this may not be necessary on linux.
Enable php_fileinfo.so.  Typically this just involves adding a line in php.ini:
```
extension=fileinfo.so
```

* some wikimedia images don't load under linux
  + don't really have to support all filenames
    + but wikimedia images are important for online sfun demo

* substitute hamburger icon for class="icon ion-navicon-round"
  + it always needs to be 10% of the screen
    + because it's way too small on mobiles in ems
  + need to set font size
    + so can't be a percentage of screen height
    + although could do in javascript

* rewrite buffer function
  + we're buffering wrong
    + we're queuing events, then only executing the first one
      + should be executing that last one
  + do I need to buffer the drop function?
    + not always (not now) but it is possible
    + we don't make the decision about whether to drop or not
      + until we receive the next event
        + or timeout
      + we only need to buffer it for one call
        + if there are n events
        + ev0 gets dropped when we call ev1
        + evN gets executed

* click an image to fullscreen
  + gets a wierd offseq
    + only happens in some folders
      + suspect related to cell aspect ratios
--o--
* changing breadth needs to zero offseq
  + because we can end up with an offseq > 1 cell width
    + which then locks the scroll
  + cell count fullscreen is wrong
    + cellmajor is about 1271
* cell widths are wrong
  + looks to me like the cell widths are wrong d=h&b=1
    + should be able to see a bunch of images side-by-side
      + I'm not entirely sure that's true
      + may have been a design decision
        + it would have to be a javascript thing to change the cell minors
          + look for change code on resize
  + can probably break this apart
    + try and take cell widths from real cell
      + that way it won't matter if cell widths are being set or not
    + nope, that's not going to work
      + because we're guessing cell width ahead of a viewport change
        + that means we need to work it out
  + try to find references to image-ratio
    + because we must use that for the cell resizing
      + right, we are setting cell width
      + but it's being lost in the CSS inheritance structure
      = sorted
  = now offseq seems to be correct too

* up key doesn't do the same as left arrow

* instrument event ordering
  + need to see what's happening with the different events
  + visualising the queue is neat
    + potentially useful for other projects
  + visualisation as separate queue?
    + one copy exists in DOM
    + one copy exists in eventQueue as critical_section linked list
  + API
    + call a simple updateVis() function
      + compare critical section linked list with DOM?
  + can't see a reason to introduce another cache
  + I think we're missing some scroll events
    + I'm pretty sure they're getting processed
      + but they don't show up in the event queue
      + perhaps because they're resolved before then
    + there's a lag
      + it shows the previous event only when processing the next
        + this is really interesting
        + looks like we keep the first scroll and dump the last
          + which is crazy
          + because it's the more relevant
  + make it look nicer (font)
    + try to allow it to wrap
      + because overflow looks a mess

* see if it's viable to animate arrow key image movements
  + need to preserve the animate flag when parenting
    + works
    + animateable flag preserved in parent() call

* show a sequence number on event vis
  + helpful to tell events apart
    + 3 digit with wraparound
  = look up padding

* event visualisation not showing
  + seems to be rendering
    + but the cells aren't coloured
  + it was there
    + firefox window was just a little too wide
    + it was off-screen

* something funny in the ordering
  + queue string console log shows an echo
Queue string: [8] -> [10] -> [11] -> [12]
Queue string: [10] -> [11] -> [12]
Queue string: [10] -> [11] -> [12]        <- this duplicate is fine
Queue string: [8]                         <= this is wierd
Queue string: 
  + 8's been off the queue for while
    + but now it's popping in again
  + console log where it comes from
  + looks like resolve() is throwing in a couple of empty ones
  + looks like setCriticalSection() is throwing in a random value
    + numbers that aren't on the queue
  + now there's a complication here
    + not everything finds its way into the critical section queue
    + we whack events on the event queue
      + so they can be picked up and resolved once fired
  + instrumentation making it all look much clearer
    + it's a pretty complicated picture

* check delay
  + is it actually showing the right number
    + because we seem to delay[1]
      + but then queue [3] after it

* animate height to zero on vis event
  + that way things move up
--o--
* put a border around the events in the critical section
  + could just split the list into two ul

* duplicating events in 'rest'
  + use keypress to test

* add separator
  + makes no sense to me at all
          // delete previous separator immediately
          $('#eventQueueSeparator').remove();
          // add separator
          $($listitems[i]).after('<li id="eventQueueSeparator">------</li>');

* investigate things dropping off the event queue
push[6]
  event queue: [2] -> [3] -> [4] -> [5] + 6
pushOrParent[6]
  event queue: [2] -> [3] -> [4] -> [5] + 6
setCriticalSection[0]
  event queue: [0] + 2,3,4,5,6
done with criticalSection[0]
  event queue: 2,3,4,5,6
resolve[0]
  = can't replicate now

* reverse the display order of the event queue
  + I expect the current element to be at the top
    + everything that's coming next should be beneath it
  + the reason it comes out backwards
    + is that the current critical section is the first li out
      + try simple after instead of before
  = works because we pre-cache list of queue items

* fix vhost error in d7 deploy
  + turn off vhosts for checkouts

* duplicating events in 'rest'
  + key presses sorted
    + but scroll still shows pairs
  + worth sorting out
    + because debugging relies on being able to read that queue reliably
  + duplicate events don't seem to be in console output
    + suspecting overlapping execution
      + lock critical section of vis update
  + list is getting confused
    + queued events are chained off the critical section
      + parents of the critical section
    + they're a subset of all the events
    + we want to show them at the top of the list
    + all other events get inserted after
      + which doesn't work
      + because we're clearing and reinserting the same non-queued events
    + time to split up the function
  + thinking complete rewrite
    + because we really want to show something of the event nesting
      + that's true to the way events are actually stored (parents)
    + this is complicated
      + because we're trying to slow something down that happens really fast
      + while preserving the relative ordering
  + rewrite going well
    + arrays much clearer
    + just need to find a way to delete the things dropped from the list
  + resolve needs to update list
    + because we end up with (non-queued) items left on the list
      + until the next update

* the odd event is littering the vis
  + for some reason the odd 'selected' event doesn't clear
  + it's because in the resolve function call
    + we call vis before doing the resolve

* video disappearing when x-bound
  + expanding from y-bound to x-bound
    + makes it disappear
    + pretty sure it's a layout problem
  + need to ensure that the video is going into the exact same place
    + as where the image was
    + and that it has the same bounding classes on it

* hover over playing video should still show metadata

* clicking a video should select it

* set video poster image to be the same as the video thumbnail
  + that preceded it
    = very nice

* mouse over
  + volume to 100%
* mouse out
  + volume to 20%

* make video play button appear in same position and style
  + before and after we video-ready the video

* selector border can't be on videos
  + because once they're played it's not (nicely) possible to put it there
  + best to just remove for now
    + no selectreflector for video-container

* highlit sound is at odds with metadata hover
  + pointer leads us on what we want to hear
    + but the hover metadata makes that annoying
  + only show metadata when paused
    + add class to cell ($ent) to reflect playing/paused state

* the visualisation is perfunctory
  + think about dropping the vis work
  + focus on getting the thing out

* dump the queue as a simple text string to console
  + need a reference for each refresh
  + queue string shows that there's all kinds of stuff going on
    + need to make queue string make sense
      + before we try and make the visualisation work

* investigate multiple events for key presses
  + start off by snapping the fade on old keys
    + we don't want things showing at the same time that don't co-exist
  + try 0 fade out
    + it's the delay
  + could tag outgoing with 'outgoing' class
    + then if we encounter one that's outgoing
    + we could just dump it immediately
  + better
    + we want to tell any thing we're adding to delete itself after 2000ms
      + nope
      + because we don't know that the event will have been resolved
    + we only want to remove after we know it's been resolved

* investigate missing vis events
  + show re-keying
    + little flash and change text
    + not clear
      + [green] hash:seq only showing up when seq=1
      + I think all 'selected' keys should also have an associated hash:seq

* video.js working well
  + player fading out controls nicely when mouse not moving

* create server mode
  + disable access to all folders beginning .
    + initially just remove from the directory listings
    + then also explicitly deny access if requested
    + doesn't need to just be applied to server mode
      + . could be the marker for all hidden folders
  = dodged this for now
    + because most the things we exclude for a server
      + aren't particularly valuable in a home LAN setup either

* 0 assets
  + doesn't mean 0 assets
    + it means 0th folder of assets
    + very misleading
      + better just to show nothing
  + nice to show how many images there actually are in the directory
$fi = new FilesystemIterator(__DIR__, FilesystemIterator::SKIP_DOTS);
printf("There were %d Files", iterator_count($fi));
  + just do a simple scandir

* make debug a url variable
  + can't have it on all the time
    + debug should add a class to <html>

* when debug is on
  + show test suite links using class
    + but hide them using same class

* debug variable isn't being updated to 0
  + for some reason we carry on showing console.log statements
  = it's cool
    + it's just a weird Firebug artefact
      + that makes it look like we're sending console.log statements

* update image metric
  + before metadata loads
  + before thumb loads
  + change out xX% for 'Initialising'
  = that's really nice
    + much clearer

* separate re-resing from selecting
  + a slow re-res can mean that we're waiting ages for
    + the select reflector to show an image is selected
  + I suspect that's also the reason why we're slow to jump to the right place on the page
--o--
  + this is linked to a slow click
    + we need to process the jump immediately
  + check the split behaviour
    + we seem to jump to the breadth immediately
    + then follow up with a scroll much later
      + is it the scroll event that's getting delayed?
        + I think so
  + this is tricky
    + there's an array of preceding events
      + that are all getting stacked up
    + reordering events
      + each event type gets a priority
      + a high priority event jumps the queue
  + solution isn't clear yet
  + build instrumentation
  + we could split the seq change from the image load
    + either dump all image loads into a separate queue
    + or make a single event
    + seq event
      + does stuff
      + farms new event
      + deschedules itself
    + from a test point of view it's good for seq event to wait until image loaded
      + but not really from a user point of view
    + could put a flag on each event
      + that controls whether it waits to return (sync)
      + or returns even when there are contingent actions to come (async)
        + sync/async flag is neat
          + could also create a new event in the queue for the image load
          + but probably don't add to critical path
            + because it's an event that mustn't block others
              + e.g. keypresses
    + async works well
      + need to find a way for test suite to treat it as sync
        + turns out the test suite runs sync and async

* deploy
  + structuredfun-linux as submodule of drupal7
    + put in top-level
      + not inside /htdocs so that all config files aren't exposed
    + vhost in /conf
      + demo.structuredfun.com/file/wikimedia-gallery1

* selecting visible images
  + don't really want to be scrolling when it's not necessary
    + that's true of video clicks (select + play)
      + and arrow keypresses
  + offseq is a good solution
    + for a bunch of reasons
  + on a select
    + if it's visible
      + read back offseq
      + reading back is the challenge
        + the time to do it is when firing the select event
        + seq=x&offseq= calc
      + stumbled back across bindToHover
        + which does exactly that!
        = broke out into nice imageStillShiftOffseq function

* push forward with layout today
  + important for BAL next step
    + ideally I'd like to get a zoomy version working
      + but I think that's too far out
    + instead a basic layout service
      + returns JSON layout file

* layout service end point
  + reads all files in a directory
    + collects metadata
      + eventually can put that into the local sqlite DB
    + produces JSON layout file
  + do this first
    + because we may decide to pull flow server-side

* refactor orientation into meta
  + try and add width and height first
    + see if they persist
  + moved orientation
    + now thinking it should really go into ImageMetadata object

* note
318 removed if isset
assuming everything has a name
  + don't think it matter, just loggin

* not showing metadata in layout view
    + I'm not entirely sure it's supposed to be there
      + I don't think we need it
      + but I'd like to establish why it's not there
  + the two seem to be linked
    + they're not the same bug

* missing metadata in gallery view
  + for some reason it's not showing the actual metadata
    + suspect it's the javascript receiver
  + no data-native-width/height being set by HTML
    + implies that file.meta.OriginalWidth is missing

+ export metadata list as json
  + this is going to be the basis for the layout json
    + has required moving all informal classes (stdClass)
    + into formal classes (GenericEntry)
  + change out $this->stats
    + for $this->entry
    + and use GenericEntry

* test layout service at scale
  + works fast up to 1000 images
    + 500ms where there's nothing in the cache

* chopped
    // always update resolution/resolution_loaded
    if (isset($obj->{'width'})) {
      $this->original_width = $obj->width;
      $this->original_height = $obj->height;
    }
    if (isset($obj->{'newwidth'})) {
      $this->loaded_width = $obj->newwidth;
      $this->loaded_height = $obj->newheight;
      $this->calcRatio();
    }
  + because we not longer store these widths in obj (GenericEntry)

* problem
  + we're generating bad images
    + they've all got crazy zoom
  + it's to do with getting original_width into metadata
  + shouldn't hold on to metadata references
    + instead read out of stats
      + because reloading metadata changes the object
  + problem is when we serialise the data back to the original image
    + it's wrong
    + it still contains that loaded_width = 200
      + but for the original image
        + the loaded_width = original_width
  + several problem persist
    + data-native-width missing again

* problem is writing native-width into HTML
  + when we don't know what it is
    + shouldn't write if null
  = first load fine now

* second load has diddy thumbnails
  + suspect it's a problem with the cache lookup

* subfolder_count bug
  = renamed subfolderCount

* have a crack at changing the way filenames are encoded in the cache
  + will help identify which entries in cache are which files
    + useful for next bug
  + compute cacheString differently
    + tweak GenericEntry to maintain URL-to-here, then add leaf
      + need to feed original URL through to FileReaders somehow

* playspace not displaying correctly
  + suspect it's a share bug
  + could be something like no OriginalWidth set
    + because the images have never been edited before
  + improved
    + it's now showing images
      + but we're not getting reres
      + I think it's to do with the metadata returned to js
        + looking for originalWidth
          + search for
refreshMetadataApplyToFields function
      + suspect we're not writing originalWidth and height into cached files
    + that's resurfaced in wm images
      + chase down missing originalWidth

* faster image delivery
  + can we use an alternative character in the URL to replace /
    + not \ because can't use it in files
      + . maybe
        + that's a bit of a pain on windows
        + seems to work ok
      + but too easily confused with extension
    + actually maybe \ is perfect precisely because we can't use it in files
      + that means we'll have to rewrite for cache

* missing IPTC
  + showing 'Untitled' for some images
    + when read from IPTC section rather than from unserialize
  = this could just be the image files I've got stored locally
    + ignore for now

* hover over icons isn't working
  + important for showing metadata
    + was pointer-events
  + edit metadata click not being picked up

* dump urlKey for now

* bring PHP test suite back to life
  + start by commenting all the failing tests
    + get a sense of the scale of the problem
  + it's not too bad
    + only a handful of tests fail
    + it's a good thing to do
      + we need it when refactoring
  + only two tests still commented
    + just the imageTransform tests
      + really close
      + on we go
  + 1 to go!
  = all green

* mouse wheel scrolling stops working sometimes
  + to do with offseq
    + and cell width
    + once offseq is greater than cell width
      + it doesn't scroll
--o--
* offseq clipping
  + we need to cover the case where a link viewed in one browser
    + is transferred to another of a different size
    + or the same resized
  + this is probably the solution to scrolling blocking
  = done I think
    + needs testing but I reckon it's close

* mark this release as 0.9.3

* update offseq when page is scrolled
  + could be mouseWheeled / paged
  + or scrollbar dragged
    = this works, but it's exposed another bug

* introduce ticker on event queue
  + update every 2 seconds while there are _any_ events on it
    + only in debug mode of course
  + do as 2 second timeout
    + that gets cancelled if we're called within that 2s
    + gets rescheduled everytime until there are no events left

* basic website
  + plug the demo link into the demo menu item
    + simple external link is fine
  + try and take :8097 out of demo.structuredfun.com link
    + drupal7 vhost should allow simple config

* release a fresh copy of the code
  + 0.9.3
  + follow procedure in this file

* default metadata not being filtered
  + I think it's javascript
    + stripping the iptc_default
    + defaults should not have _
      + because they're compared to real names in the javascript
    + don't override filename if no metadata value set
      + currently overriding to 'Untitled' then not showing that
        + it's happening in the javascript
  + implemented a clever filtering thing
    + splits out the logic better
      + might move some of it to css in the future
        + but it's marginal now

* get loaded width and height into layout
--o--
* see if layout is different from directory
  + use var_dump
  + looks like we're not getting imgdata
    + even though the images are cached
  + getCacheKey is returning a superfluous value
    + a full filepath
  + got to setRawname on all directory entries
    + they all need to do meaningful cache lookups
      + go to where we create MetadataFileReaders for each dir entry
    + setting rawname in FileviewController and LayoutviewController too now
    + now we need the standard args on the end
      + consistent with the 200px image request
    + try and share standard args using source controller
      + currently replicating
        + it's all the same data
        + so better to store it
          + should be able to pull it out of the mfr
            + because it's injected

* make horizontal default scroll

* might need to handle case where the metadata saved in the file is sfun
  + but older than the current metadata
    + nice to have a single calc() method
      + that derived all derived fields
  + also like to define a mergeold function
    + that mapped older schema to the current one
  + hasn't cropped up yet

* nulls slipping through in ratio
  + probably error image
    + verify
  + needs correcting when loading the error image
    + slightly complicated
      + start by just checking that it works if we fix the ratio
    + now it's correcting for all images
      + it should be able to load some
  + might be caused by a badly serialised ImageMetadata class
    + stored in the original image
      + I'm not sure we should do that
        + back to migrate/updateold/mergeold
    + hard to prove
      + look at deserialised ImageMetadata
    + this is really complicated
      + it definitely something to do with old images (0.9.1)
    + seems not to be able to read the imgdata
      + even though it can pull the metadata from it
  + restricted it to getAll()
    + that's the only case where we fill the metadata in
      + if it couldn't be read

* images not being loaded in layout view
  + more images fail in layout view than in directory view
    + could be memory limit maybe?
      + tried higher memory limits (< 10240M) and still get 5+ error images
  + instrument with memory_get_usage()
    + doesn't seem to be running out of memory
  + best guess seems to be non-standard characters
    + fix 1 manually and see if it loads
    + /tmp/wiki... isn't the same folder
      + fixed it
  + need to handle names in the same robust way
    + for XviewController and force getDirectoryEntryMetadata
      + it's in 'name'
    + find the code that handles name string conversion
      + it's done in FileReader
      + we convert it into utf-8
        + which breaks when you put it back into a filename
    + could reverse
      + but doesn't seem to work cleanly
    + could store original name ($v)
      + that's probably cleanest
      + having some problems using the right var at the right time
$fullname .= DIR_SEPARATOR_URL . $obj->getNameOriginalCharset();
        + need to carefully use right name in a few key moments

* check test suite following introduction of getNameOriginalCharset
  + all green

* layoutview doesn't seem to be pulling properly from the cache
  + takes the same amount of time with/without a primed cache
    + ok, better now
    + because only using getNameOriginalCharset() in getFullname()

* store normal_width|heights with both breadth and direction
  + because they'll be different

* debug flow jitter
  + after developing layout
    + or not
    + pulled forward because of potential of demo
  + it seems like it can't decide between flow and grid
  + seems to be do with rolling ratio_ variables
    + found @todo to suggest stripping it out
  + doing this in HTML makes the most sense
    + each image can be tagged with its normalised position
      + if the entire image set is laid out at this breadth
      + where would this image fit
        + depends a lot on the viewport height (vh)
          + but I wonder if we could solve in terms of vh
            + wow that's interesting
      + put ratio on each image
        + then combine in 2/4/8
        + put ratio on combined
          + data-ratio="3/2" data-ratio-2="3/4" data-ratio-4="3/8"
        + then sum the ratios additively
          + data-ratio-sum="" data-ratio-2-sum=""
        + so that to get position
          + we just mux data-ratio-sum by viewport height
      + this is really good for a bunch of reasons
        + don't worry too much about the first layout case
          + solve for nth, then work backwards
  + how to handle errors
    + if we can't process an image
      + replace with the error image
        + and use the error image ratio
    + error images are part of the layout too
  + run a single test class or file
    + Windows
phpunit -c app src\Lightenna\StructuredBundle\Tests\Controller\LayoutviewControllerTest.php
    + Linux
phpunit -c app/ src/Lightenna/StructuredBundle/Tests/Controller/LayoutviewControllerTest.php
  + ratio is null
    + because we're not get()ing the images from the cache
    + layout controller might need some kind of cache all call
      + that could be slow
      + useful for the test suite
        + perhaps not in real use
      + missing args
        + normal_width|height not showing
          + being lost in serialise
    + transpose javascript
  ? all normals should be less than 1
  + where a normal is > 1, it's wrong
    + no no no
  + normals can be bigger than 1
    + but minor axis normals should sum to 1
* work out normalised positions (normal_x and normal_y)
  + done for x>1 || y>1
  + do for x=y=1
    + can't do n=1 the exact same way we did it for the other ones
    + because it doesn't share a running_major|minor with n>1

* implement canvas thinking into layout

* not reresing
  + because we renamed .meta to .metadata
  + had to tell js

* disable flow

* check what happens to layout if we haven't cached the images
  + division by zero

* protect layout against missing ratios
  + just assumes they're error images
    + which isn't unreasonable
    + because we'll still show the actual image in that shaped cell

* create layout class
  + break code out of LayoutController
    + because we want to also call from FileviewController

* use layout data to display images
  + push lots of layout data with directory if available
  + test case where we have no cached data
    + everything assumes the error ratio
      + which is correct currently

* test how arrays show up in twig->HTML

* reposition mediacache in core
  + need to add to htdocs
  + update config

* try and write redirect
  + fun to have cached images loading super-quickly
    + URL testing
curl -Ls -o /dev/null -w %{url_effective} 
  + slashes are not that important
    + we could use another character
  + we'll have to use another character anyway for IIIF
  + need to make mediacache web accessible
    + at the moment it sits above htdocs
  + rewritemaps are only exact matches
  + tried simple listed rewriting
    + close with this
# matching exactly 2 slashes
RewriteRule ^image/([^/]*)/([^/]*)/([^/]*) http://%{HTTP_HOST}/mediacache/$1_$2_$3.dat [L]
# matching exactly 1 slash
RewriteRule ^image/([^/]*)/([^/]*) http://%{HTTP_HOST}/mediacache/$1_$2.dat [L]
      + but can't test if the file exists
  + need to test if file exists first
    + that's tricky with rewriting
  + simplest way forward is to encode the filenames in PHP
    + ask for an image that already has substituted _ into it
    + also fits for IIIF later
  + rewriting working nicely
    + now just need to fix the imagemeta mess
      = sorted

* remove mediacache from sfun-linux and sfun-pc

* make basic image caching work on linux version
  + cache directory needs to be writeable
    + and need selinux permissions too
  + simple fix
sudo chcon -R -t httpd_sys_content_t mediacache/

* revive flow1
  + like to understand how close it is
  + flow1 and flow2 address two entirely different use cases
    + flow1 for real-time image folder browsing
    + flow2 for web-based gallery repeat viewing
  + ratio is null for imagemeta
    + probably related to cachekey
      + which is used by existsInCache
    + status:-1 even though mediacache directory full of images

* exclude normalsHTML from JSON output
  + imagemeta doesn't need it
  + and quotes get escaped which looks messy

* good to understand what's fighting with flow
  + we're about to change out flow for flow2 (based on normals)
  + before we do that
    + good to pre-empt a confusing bug
  + try to ignore it and let's see if it's a problem
    + can't
  + it was caused by clearCells
    + but we do need clearCells sometimes
  + this all need a pretty major overhaul

* do layout based on normals
  + at the moment don't worry about the realtime use case
    + we just need to get a flow layout working reliably
  + see if there's a way of getting the viewport height server side
  + there are a few different ways of doing this
    + and they're all slightly at odds
  + simplest is to refresh all the cells in one go
    + but there's a lot of redundancy
      + and that's a big problem in the event of a large image set
      + which is a sfun USP
    + refreshing just a small set of images looks best
      + that's most easily done using normalsX
      + which means sticking with the current model
    + could write out lots of css
      + each image gets a width and height in px
        + really nice to set a width in terms of percentage height
        + I think I've got to do that in js for now
    + judging by past experience
      + best thing is always to pull it out and do it properly
      + refactor refactor refactor
  + do flow2
    + but implement it based on visible image blocks

* persist with flow1
  + see if we can make it work
    + it seems pretty close
* make flow1 scroll work
  + it's not detecting new images to the right (major positive)
  + cellsResize needs to resize the currently visible images
    + and a sufficient number of visnear
      + so that future scrolls work
    + maybe expand visnear
  + this is a good plan because we're exposing problems in the core
    + visible and visnear are wrong
      + there are loads of visible images that are only flagged as visnear
    + after a cellsResize we need to refresh the visible/visnear status
  + solved a nice bug to do with refreshing visTable after refresh
    + always always always refactor refactor refactor

* changing between breadths
  + need to trigger a resize
    + try a cellsClear and resize
  = seems ok

* centre offseq is broken
  + probably because we're no longer calculating the total ratio
  + will need to rewrite without using ratio total
  + close
    + on selecting fullscreen
      + we should use the image we're about to select
        + not the image that's currently selected
    + ultrawide images
      + can send to negative offseq

* cover off non-flow centreOffseq
  + centre offseq should be layout independent
    + move clever offseq out to flow
      + need to work out how to get return values back from layout[] calls
  + could make it just 0
    + because when fullscreen
      + the cell is 100% major

* suspect ratio is not being set
  + when coming from imagemeta
  + first load doesn't drop into flow
    + second load is fast

* getting a black flash on flow refresh
  + not sure why
  + not dealing with it now
    + comes and goes a bit

* cache imagemeta too
  + not important enough now

* page down jump
  + the event sequence seems to go something like
    + keypress
    + scroll
    + selected
    + scroll
  + disable animation and see if it's still visible
    + it's not!
  + double event is caused by animation
    + need to ignore scroll events until we get to the final one
  + need to cover the case where
    + scroll doesn't end up exactly where it thought it would
      + in which case
      + should just use last buffered
    + try extending the buffer timeout
      + not viable
        + because the old scrolls still get buffered
          + not clear on whether they get executed or not
          + but there is a visible delay in the animation
    + interestingly it's the midder event that gets executed
      + scrolling to x=0
        + executes x=55
      + scrolling to x=1164
        + executes x=1082
    + looks like we never get the actual last scroll event
      + there's no x=0 or x=1164
        + the handler does actually get called
        + but that x=0 or x=1164 event is already in the queue
          + and it swipes it
      + we just need to detect that queued scroll event
        + and consider it the first buffered event
          + so that we dump all the following ones
          + could do that with a call to buffer
          buffer('handlerScrolled_event', ...);
        + not quite as simple as queuing the first one
          + it's more that when we receive the handlerScrolled call
            + for the last one
          + we need to buffer it
            + so that the preceding call doesn't get executed
      + has the peripheral benefit
        + of allowing us a mechanism to delay the post-scroll calls
          + that means the high-load JS activity
          + can be delayed until after the animation has finished
      = that is absolutely lovely!

* trigger layout refresh (cellsResize) after image load
  + introduce a check upon image load
    + to see if all images in a minor (column/row) have loaded
      + if they have, we want to do a refresh
    + that refresh will invalidate last_n+1..n
      + so calling out of order could be tricky
  + the cost of re-executing isn't too bad
    + maybe for now (flow1) we've just got to call
      + cellsResize after every image load
        + sort of happens already
setVisibleAll() -> refreshVisibleImageSet() -> refreshAnImageSet() -> cellsResize()
          + other than it doesn't happen on first page load uncached
          + trace through handlerHashChanged to see if
            + if we come close to some kind of setVisibleAll
              + it's close
              + we do a forced handlerHashChanged()
                + but that's not really the right place
                  + because it's very slow
        + could do a cellsResize after every image load
          + but only if we can tie it to just the first load
            + don't want to get caught up with a reres
  + this doesn't just affect the first load
    + if I whizz up to new images
      + it'll load them
        + without cellResizing afterwards
      + I think it's because we made the image thumb load async
    + it's probably calling cellsResize
      + but early doors
      + start by sticking a console log on cellsResize
        + just make debug=1
        + turns out it calls it 5 times!
          + but not after the metadata is loaded
  + every time an image loads for the first time
    + we want to see if it completes a minor (column/row)
      + then call cellsResize just on that minor
    + this should be keyed upon the actual image load
      + which we normally do async
        + image load should continue to be async
        + but we'll add in this check
          + sync upon image load

* working on cellsCheckMinor
  + need to be able to differentiate
    + cells that have an error ratio set and
    + cells that have a real ratio set
  + at the moment we're giving cells a "cell-flow-specific" width
    + when they shouldn't have one
  + either split data-ratio
    + into data-ratio-layout and data-ratio-cell or
    + introduce a new field to flag status
      + suggest status
        + consistent with layout
      + share status codes between JS and PHP
    + use status codes in JS
  + status codes made cellsResize work
    + now it's resizing correctly on first load

* thinking about an optimisation cycle
  + things are a little jerky
    + can't put my finger on it
    + but I feel uneasy using it

* disable flow to see how long black screen persists
  + is black a flow artefact?
  = yes
    + without flow there is no black stage

* long black screen on loading
--o--
* try using minor-based resize
  + without using cellsResize on refreshAnImageSet
    + we stay with a black screen
  + I suspect the blackness is caused by something waiting
    + triggered by cellsResize
  + works well

* not updating quite wide enough
  + scrolling up the directory doesn't load images
    + suspect we're not resizing far enough up
  + looks like we're not refreshing the visTableMajor at all
    + better to escalate cellsResize call back up to main
      + if it happens entirely within flow
      + we never update the vis table
  + could return range {} obj back to cellsCheckMinor call
    + doesn't really work with deferred
      + can live without deferred
  + interaction with cellsResize is tricky
    + we want to call cellsResize (main) because
      + its wrapUp() function handles updating the visTable

* some events need to trigger a complete cellsResize()
  + events
    + breadth change
    + direction change
    + window resize
  + not easy to get these
    + actually not that bad
    + because the dep is that the cells have ratios
      + not that they've been loaded
    + so could just resize before updating vistable
  + doesn't behave quite right
    + stripped out
    + now searching for a partial resize way of handling these events
  + let's try a cellsResize after envisionSeq
    + not quite right either
  + cellsClear play?
    + when clearing cells
      + also reset image status?
    + we want to periodically invalidate the cell-specific widths/heights
      + cellsClear is the place
      + then ensure that the next image load triggers minor (column) resizes
        + the next image won't always be loading
        + sometimes we'll have loaded it already
          + falling back to do a cellsResize on refreshAnImageSet
    + it's not perfect
      + but it'll probably do at this stage
        + until we validate with users
      + it works ok on a PC
        + there are some roots showing
          + but they're not a big problem now

* chase down empty events
  + generated reliably doing a refresh
    + on a breadth=1 imageset
  + clicking event queue could expose more information
  + might be able to catch them with a breakpoint
    + add a click handler
    + then stick a breakpoint on the click handler
  + caused by api_triggerScroll
    + which creates a blank event
      + to hold the replaceEvent: true flag
      + to enable numbing
    + filling it with a key is fine
      + but creates duplicates
    + filling it with the same key is fine
      + but it reuses/sisters it
      + and crashes horribly with an infinite loop!
// crop the target position against reachable bounds
target = cropScrollPositionAgainstViewport(pos);
// create a null context to numb the event listener
var localContext = eventQueue.push({
  // key is cosmetic; envisionPos call will spawn an inheritted context
  'key': 'scroll:'+'x='+target.scrollLeft+'&y='+target.scrollTop,
        + but something in that vein maybe
      + if we detect the same key
        + we could reuse the existing event
      + nope
        + can't have 2 events with the same key
          + it confuses it
    + just create two events
      + parented
        + and parent resolution works fine
    + looks like these trigger calls never actually generate scroll events
      + so they don't get resolved until there's a 'checking expires'
      + print scrollHandler log to check if we see them at all
        + we don't
      + check another browser for consistency
    + just leave a @todo there for now
    + actually implemented in api_triggerScroll

* firing loads of imagemeta requests for dead images
  + should protect to make sure we only ever have one call outstanding
    + not entirely sure what that'll do to
      + because the latter requests
      + eventually get results
  + could just avoid firing them for error images
    + check HTML, look at status
    + would need to properly set the status
      + it's currently -1 (missing)
        + those images need to be -2 (error)
        + because we can't actually load the images (only on this setup)
  + for now just protecting against multiple fires using 'data-loading'

* mouse wheel (PC) loses offseq centring
  + yet arrow left/right/up/down works perfectly
--o--
* make handlerMouseWheeled recognise offseq
  + needs to preserve offseq when set
  + needs to introduce offseq when not set
  + broadly handlerMouseWheeled should advance by 1 minor width
    + e.g. 1 column width for dir=x
    + when using imagesnap
  + now do we key that off
    + the image/minor in the centre of the screen, or
    + the current selected cell
  + selection is tricky
    + because scroll doesn't necessarily update it
      + unlike arrow left/right
  + summary
    + arrow keys are image-aligned
    + page up/down is not image-aligned
    + wheel up/down is image-aligned (in imagesnap mode)
  + steps
    + preserve offseq
      + just use whatever value is set when we start the scrolling
    + recalc offseq for the next image
      + that's tricky because we're currently getting the next image
  + just using same imageCentreOffseq trick
    + getting stuck when b>1
      + probably got to start using an hash change
        + because when we're scrolling into unknown territory
        + it's impossible to the alignment right
          + because we haven't loaded the image
      + thing is we don't want to make scroll a hash change
        + it needs to be lightning fast
    + simple hack to avoid doing anything clever where b>1
      + good enough for now

* flow cells reaching more than 100%
  + major and minor cannot exceed 100%
  + use viewportBounds
    + because it's exactly the right size
  + we are now cropping to 100%
    + but 100% exceeds the space available
    + fix with border review

* no js, make css fullscreen fill the screen
  + 100%, not 100%-8px
  + horizontal to vertical transition is seamless

* horizontal to vertical transition
  + at breadth=2
    + or breadth=4
    + because it's the same
  + all b>1 jitter
    + it's a minor border
  + I think we can tune it with offseq
    + basically offseq should always be +gutter
      + default offseq = 0
        + and it should be
        + and default disappears from url
      + but it should be bordered in

* border review
  + when there's no flow js

* border review with flow
  + breadth=2 particularly
    = seems solid

* border appears on bottom of b=1 flow
  + because css says no border (flow-1)
    + but javascript is subtracting 2x gutter
  = done but created another issue

* fullscreen images under flow
  + 100% wide images missing right hand edge
  + need to create a separation between
    + actually viewport limits
      + used for cropping
    + the image 'window' limits
      + used for scaling
        + calculated percentages may be smaller
      + probably need an extra param into
        + _cellsResizeBucketMinor
    + hmmm, maybe not
      + we're not exceeding 100%
        + which is good
        + we just need to get the bounds right
          + is there a setBound call after cellsResize
            + hmmm, maybe not
          + ideally we want to re-setBounds
            + only if we change the size of the cell
            + that's a good catch too for jitter
          + ah ha we do call setBound
            + from flow
          + looks like there's two things happening
            + first call correctly sets the bound
            + then something clears it
          + have taken out the universal y-bounding
      + now displaying x-bound fullscreen images properly

* fullscreen flow cell widths aren't quite right
  + portrait image is too narrow
    + I think this only appears after the big image
      + possibly a leaky var there
      + becoming global when it should be local
  + sort of
    + it was parent.minor
    + parent is shared across many _processBucket calls
      + so it affected all images after the widey

* check commit
  + because today's deploy didn't work the way I expected it to

* jitter was solved by stopping flow forcing all cells to y-bound
  + because the follwing setBound call
    + would then reset to x-bound for some images
  + then it would get reset back to y-bound
    + again (hence jitter)

* strip layout from core
        // try and lay them out
        $l = new LayerOuter($listing);
        // calculate multiple layouts (fast)
        $l->layout(1, 'x');
        $l->layout(1, 'y');
        $l->layout(2, 'x');
        $l->layout(2, 'y');
        $l->layout(4, 'x');
        $l->layout(4, 'y');
        $l->layout(8, 'x');
        $l->layout(8, 'y');

* 4px creep when doing arrow next/previous/next/previous
  + it's because we're not reading out the gutter
    + when we're calculating the next offseq
  + offseq is incrementing
    + each read of position is true
    + but each write has a + gutter on it
      + solution is to subtract gutter from read
    + confirmed that it's caused by flow.js
      + but I'm not sure it's imageCentreOffseq
        + because we're not actually trying to centre the image
    + could be imageStillShiftOffseq
      + but addition of + gutter I think is done in flow.js
        + ha it's not
        + it's in envisionSeq
      + it's the offseq calculation that's wrong
        + because it's incrementing
        + so that's the place to subtract it from

* remove data- attributes from noscript
  + contradiction

* variable width cells
  + constant border allocation is causing unevenness
  + even though it's a small total (16px)
    + it still needs to be allocated according to the cells

* fix two broken images
  + expand memory_limit
  + drop unused text file

* get PHP test suite running again
  + with layout in AddonBundle
  = it is running
    + there's a silent error in there about reading 0 bytes
    + but it's good enough

* jump back from fullscreen isn't quite right
  + even without flow
  + it jumps further back than it should
  + trick is reading offseq ahead of the breadth change
    + the existing URL is probably out of date
      + unless we happen to fullscreen the current (selected) image
    + but we can readback a new offseq

* make right arrow advance by a column
  + because up/down should take you up and down
  + but left/right should travel
    + always, not only when wrapping around a column (minor)
  + only when going horizontal

* push settings into javascript
  + generically
  + start with GA js

* stick version number from ImageMetadata
  + as sfun_version
  + push into settings->client

* v=undefined
  + not getting version number yet

* GA add hooks
  + add track->event() call to key points across codebase
  + event (action), category, label
  + could categorise using current state
    b=1, d=x
    + breadth
    + direction
    - not
      - offseq (too transitory)
  + possibly label = seq
    + might be interesting to track where the events take place
      + will almost certainly generalise
      + stuff other parameters in there
        + because label is searchable
        + GA filters are quite good
  + we want to be able to differentiate
    + scroll events that we originate
    + from those that are genuinely fired by a scroll

* GA track event add image clicks

* chrome getting stuck behind an event
  + not sure why
  + only happens in chrome
    + happens when seq > 0
    + so can do a fast base load of blank URL
  + seems to be getting stuck behind a scroll event
    + could be to do with the latent scroll event
      + where the browser injects a scroll event for its last position
  + show event handler traffic
    + event sequence
0:hash seq
    + fires scroll event
  1:scroll 2106
    + somehow another scroll event gets pushed
  2:scroll 1182
    + and delayed
  + so 2 isn't being allowed to execute
    + because 1's outstanding (child of 0)
  + check expiries kills 0
    + which allows 2 to execute
  + couple of solutions
    1 numb out the extraneous last-scroll-from-browser event
      + not sure at this stage how reliably we can do that
    2 unlock scroll so that we can't get into the position
      + of waiting for a scroll event that doesn't come
        + because it looks like it does come
        + but doesn't get dealt with
          + I guess because we dump it
            + bingo
      + we mustn't just dump it
        + maybe we have to resolve it first

* folders are linking using ~dir~ aliases
  + they don't need to
    + and it looks weird in URL address bars
  + can and should use / notation

* check that we haven't knocked sfun_version out of ImageMetadata
  + it's a definition
    + but I'm not sure we're picking it up from ViewController
  + worth checking
  + write a simple PHP unit test
    + just instantiate a new instance of ImageMetadata
    + test version number is set
      + strlen >= 3 is fine

* reading metadata on directory entries
  + which causes errors
    + print a trace
    + print_debug_stacktrace kills the browser
  + worked it out manually
    + seems to go back to getDirectoryEntryMetadata
      + to getAll()
        + we force metadata reading without filtering for images

* GA track event add menu items
  + not seeing header_8 events

* look up how to do a deserialise on json content
  + we want to be able to use /layout route internally
    + because it will handle caching
    + and lends itself to service separation

* try to get symfony to find AddonBundle routes
  + works nicely

* move AddonBundle out of the way
  + try to make codebase behave without it
  + haven't reached the conclusion of this
    + need to manage app/routing.yml
      + basically we can't reference AddonBundle's routing.yml
        + because it may not exist

* get codebase into a commitable state
  + can't have static route inclusion
  + need to find a way to add that back in

