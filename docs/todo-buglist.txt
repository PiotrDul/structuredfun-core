
* fun optimise
  + visTable.updateAll
    + called a lot
  + get offsetWidth (jquery) called from refreshMetric and setBound

* fix failing test
  + 'reres of last page of images'
    + failing only sometimes in on folders with nested folders (at the end)
      + fails in both Firefox and Chrome, so not a browser thing
  + failed with flow on

* rapid scroll is a great test
  + nicely illustrates delaying
    + worth coaxing that test to be as hard as possible
  + shows a couple of things
    1 selected events never get resolved
      + they only get cleaned up by checkExpiries
        + they are async
          + so they're not holding anything up
          + but they can be resolved earlier
        + should resolve on replaceEvent
        + looks like replaceEvent functions aren't resolving their parents
          = now they do
    2 scroll is currently sticky
      + it's not currently jumping out of order
        + at least not on this computer
      + but it's not smooth
      + looking at the logs
        + there are heaps of queued scroll events
          + that all get resolved at the end
          + I think they could all get dumped
            + my only worry is that dumping might hide other problems
        = ok, tested on larger, slower image set
      + but let's work on selectively dropping events
        + 3rd queue seems to be the way to do it
          + that means deciding what to drop in getOrInvent
      + say there are many rapid [scroll] events
        + A B C D E F G H
      + dump by removing from unhandled array
      + 2-deep dumping algorithm
        + we catch A
          + start processing it
        + B gets queued
        + C gets queued
          + dump B
        ...
        + H gets queued
          + dump G
      + dumping is a little more complicated
        + when dumping B
          + C needs to get parented to A
      + getOrInvent is tricky
        + by the time we get the call from getOrInvent
          + the event has already been fired by the browser
        + we've got a very short space of time to decide if we're going to decide
          + to process, queue (by parenting) or nullify (by returning null)
        + there's got to be a sort of 3rd way here
          + when we're processing C (in getOrInvent)
            + we're going into the A-B parenting relationship
              + already setup in actOnContext
            + and unpicking it
        + getOrInvent pulls matching element from eventQueue
          + or creates it
            + so think 'C'
          + at the time we see 'C' we don't know if we're going to queue it (parent it)
            + because we're just inventing it or pulling it from the eventQueue
          + alternative time to do dumping is when we queue
            + which makes it part of actOnContext
            + we're getting towards the idea of two kinds of 'parent'
              + real parents
                + where the parent spawned the child event
              + execution order parents
                + where the parent needs to be executed when the child completes
            + we generally use it in the second context
          + the only time this comes up is when we process a torrent of events
            + we end up with a very unrealistic chain of unrelated events
              + the only interesting thing is we do it in the opposite direction
              1 handlerHash -> fireScroll
                + sets up scroll event as child of handlerHash
              2 actOnEvent B, while executing A
                + sets up B as a _parent_ of A
                  + so that when A completes, B gets kicked
              + these two things shouldn't be in the same queue
                + 1 should be chains of events
                  + using the existing mechanism
                + 2 should be some kind of macro level thing
                  + like a straight-forward list at the eventQueue object level
              + how much do we re-write now
                + I think first thing is to test the effectiveness of dumping events
                + I'm also not sure that we really want to split these into two queues
                  + the intersection between those queues requires management
          + events go through a few key stages
            + getOrInvent, simple single events, no deps
              + they don't get handled until after actOnContext
            + actOnContext, some processing done but no downstream events
              + safe to make parents of current critical_section
                + can hunt for similar peers

* use rapid scroll test to show that
  + some events are getting dumped
  + the last scroll event is fired and handled

* mousewheel getting delayed while images loading
  + must never delay the mousewheel
    + delay shows up even better with flow on

* directory thumbnails need to load bounded
  + partial flash looks weird

* load correct-res shortcut not working
  + it is working
    + it's just that the nearvis image loads
      + are somehow still using the thumb res
      + it was nearvis
    + insert into test suite
* write test to check that correct-res shorcut is working

* play with image overlays
  + couple of possible routes
    + python to opencv to imagemeta
  + image augmentation database
    + at the point of serving up an image
      + look for more metadata in central DB
        + annotate the image that's returned to the browser
        + look at options for pulling metadata directly from image using JS

* could pursue buffer() for speed
  + we're processing too much during a scroll
    + stick a delayUntil on a context
  + everytime we put an event into its critical section
    + we want to check for and resolve redundant events
      + do that first, then do delay

* check that we only start doing stuff on nearvis AFTER we've done everything on visible/vispart
  + there's a short delay then it seems like nothing is happening
    + I suspect it's because we're doing nearvis

* look at .find calls

* apple scroll is too fast
  + log the scroll events
    + research way of detecting apple trackpad
    + worst case we read the OS from the browser string and assume

* loading seq=high shows a tiny slice of the previous cell
  + happens for direction-x/y
  + even at offseq=0 (default)
  = almost sorted
    + just need to tweak the rounding so that we don't include vispart
      + where the near edge of the cell is actually offscreen (0 to -5)

* cold load seq=high jumps in Chrome only
  + something to do with the final stage
    + from container offset to scroll
  + there's a difference in the cell widths between hash->setScroll and scrollHandler
    + I suspect
      + we're collapsing it somehow
      + or chrome is collapsing it
    + verify by
      + checking fiddle
        + doesn't seem to happen
      + jquery checking the cell widths
        + seem fine
      + F10ing through things it does in between
  + start by disabling flow
    + see if this occurs with just the basic layout
  + gaining some insight into this
    + it looks like (without flow) cmd+r reloads the page
      + and triggers a scroll event to return to the same place in the document

* loading near far edge with lots of directories
  - introduces shuffle
    + and events go mad

* remember dimensions of last resize
  + and somehow tag onto cell
    + so that we don't have to resize cells that we've already resized
--o--
* remember dimensions of last reres
  + and somehow tag onto cell
    + so that we're not constantly asking images to reres unnecessarily

* imagecreatefromstring is stumbling over gif
  + look at AE

* start with pc, but set cell sizes using px after that
  + otherwise we get very strange effects during resize (at high seq)

* eventually capture -8px margin on #sfun
  + before changing it to realign major
    + so that when we apply new value (to realign the major axis)
    + it includes the -8px
      + otherwise we show a little edge
  + not sure if this is necessary or not

* need to wait until there are no scroll events before realigning
  + otherwise scrollbar goes all over the place
  + could search the eventQueue for any other scroll: events
    + could flag each event as started
  + does buffering solve it?
    + means that repeat calls get ignored
      + not sure
      + worth investigating first

* scrolling backwards beyond visnear
  + jumps forward to show selected
    = try just buffering

* rewrite test logic, just document here
    + cold load 0
    + cold load low seq
    + cold load high seq
    + load 0 skip low
    + load low skip high
    + load high skip low

* jumping to seq creates different results to reloading to seq
  + like before, seq gets kicked right by preseq images loading

* re-enable scroll buffering

* staged scroll should go row-by-row or column-by-column
  + also centre using offseq=centre
    + a number should preserve the number of scroll
      + but centre is more meaningful

* page up/down needs to work on viewport pages
  + can't rely on jumping a certain number of images forward/back
    + because they could be really narrow

* use offseq to maintain the relative position of the current seq image
  + fun to watch it grow and shrink

* sfun button needs to go into the corner
  + been pushed out by some padding/margin

* end event is resolving slowly
  + only after 10s expiry
  + it's getting lost during a scroll update
    + we know because it's a scroll:x=1799 event that expires
      + which triggers the original keyPress to resolve
  + the disconnect seems to be happening
    + because we try and scroll to 1799
    + but the scrollEvent that comes back is only to 720
      + could solve by estimating position of window near END
      + better to solve with wildcards
    + need to create an eventContext really early
      + at the point where we fire_keyPress(key_END)
      + that eventContext needs to be passed all the way through
      + and contain a wildcard
        + to connect with ambiguous scroll-to-end
        + now that's actually quite hard
          + the event changes nature with each pass of the batton
          + we're basically saying
            + when you fire a scrollUpdate for this,
              + call it something else
            + that's not an easy narrative
    + alternative is to soften the link between all fired scroll events
      + and the handlers that immediately follow them
    + or some combination of the two
      + something in the master eventContext
        + that says soften the following
          + temp issue: not timing out old events
    + alternative might be to try and more accurately guess
      + where scroll event will actually go to
        + i.e. document end - screen width
      + could do that as a simple max on the fire_scrollUpdate
        + that's pretty close
          + still having to expiry it though
            + let's look at context id to see which contexts are missing
      + it's clear that one of the images isn't resolving
        + when I force the deferred to resolve, everything is fine
--o--
* wire in deferreds through everything else
  + make it work for handler_hash first
--o--
* extend test suite
  + test reres
    + end
  + need to connect the deferred in the hash handler to some kind of external/api
    + pushing a value in the URL might be an option
      + but that only extends to hash values
      + nice to come up with something global
        + need to find a way to push identifiers through the event chain
          + e.g. x in scrollUpdate(x) -> handler_scrolled(x)
--o--
* end test has errors
  + some images have been reloaded
    + it's because we're resolving the scroll event after the metadata has been returned
      - not after the reres has completed
    + I can see cases where we might want both of those
      + but for now, concentrate on the images loading

* forward scroll newbies
  + newly visible images are coming into view too far apart
    + better to assume a narrower cell width then correct it
    + take an average major
      + maintain everytime we shrink a cell

* directories as full cell multi-image panes
  + basically like little microcosms of the whole screen
    + play with a border to make them look different

* selector doesn't show on two sides
  + need to show all the way around the selected image

* extend test suite once all current tests are working
  + test reres
    + mouse wheel two images right
  + test imgmetric vis

* visTable bugs
  + fairly minor stuff I think
    + use test suite to debug

* .s in directory names, like mq

* mousewheel after scroll needs to re-align
  + otherwise can be scrolling in half-images

* sfun icon
  + think about the glassbar concept
    + pushing out from the icon

* shiny menu bar

* need to get an alpha online
  + doesn't need to be a big release, but it does have to be a first release

--- first launch: it's not a big deal ---

* FEATURE: video

* FEATURE: show semi-opaque numbers in circles over each image on a direction change
    + to reflect order of images

* instead of requesting metadata
  + could just request an image of the size we want
    + (guess that it might be available)
    + and display whatever comes back
      + then request metadata asynchronously
        + and probably for everything rather than just the visibles

* thinking about maximising the space
  + could swap an image +/-1 to get it to the top of a column
  + landscape
    + could expand the width of a cell
    + could decrease the height of a cell
  + portrait
    + could expand the height of a cell
    + could decrease the width of a cell

* imgmetric as mini bar chart
  + show percentage in background too
    + visually reinforce when you're looking at massive images (small)

* page up/down should advance to next image that partially off screen

* vertical mode needs work
  + catch up js with horizontal
    + should work properly in test suite too

* show video entries in directory thumbnails

* show imgmetric on videos

* single entry in folder
  + or fewer entries that a single column
  + align left, not centre
    + which will mean it doesn't matter if we turn off border-left

* never show thumbnails on mediacache

* shuffle directories to top
  + like in windows

* introduce HTML for markers
  + directories/images/files
  + but don't worry too much about what markers we insert to start with

* shuffle non-image files to bottom
  + just for convenience

* test using app.php for everything
  + is it possible to make elan an exception (and use app_dev.php)

* think about javascript changing cell percentage based on mean row height/column width
  + alternative is dynamically reducing column cell widths, column by column
    + alternative is better I think

* cookie header options
  + to remember what we were looking at
  + think about hash-bang/url change too

* safari sometimes-sometimes-not resizing images
  + see iPad

* folders maintain square aspect in landscape cells
  + make x-bound
    + write javascript to detect div.folder width and flip class
    + write y-bound class specifically for div.folder

* Redraw folders at 1440x1080
  + 4:3

* Add ../ up arrow to directory listings
* create file icon

* Nice looking header icon (sf in circle with chunk bitten out)
* Rotate header icon on rollover header expand

* Horizontal/verical icon
* Light/dark icon

* snameed jQueryUI scroller for number of images wide/high

* make imagemeta returned JSON take IIIF Image API format

* Fail nicely when a file/directory/path element doesn't exist

* Using Project sheet in Google drive for major functional items
https://docs.google.com/a/lightenna.com/spreadsheet/ccc?key=0AuXNj3kHNsfddFhwTGZpcERMd1JweTVuMEFoS3h6YUE&usp=drive_web#gid=0










































Done
----

* setup paths bin

* install composer

* use composer to install symfony2

# install composer into bin directory using downloaded install script
php bin\install-composer.php --install-dir bin

* create a project
php -c conf bin\composer.phar create-project symfony/framework-standard-edition ./vendor/symfony2/ 

* commit everything to an open repo

* test basic route on prod

* create directory indexer like before
  + but under symfony

* setup php-dev server for dev if caching is annoying
  = didn't have to, configured normal apache to use app-dev

* setup model for record(directoryEntry)

* setup controller and route

* setup directory, file and record->directory->zip

* never add trailing / to directories
  + and make thumbnail paths work using linkpath

* Double data/ for directories with trailing /
  + http://localhost:8080/file/data/

* Images not showing from zips

* Error image

* no route found for /file

* double // for /file/ or /file

* 404 for for / or <blank>

* write test function for jazzy new performFilenameSubstitution()
  + extend to cover zips

* clipping bug when used *with* resize
  + suspect it's to do with not resetting width and height
    + better to re-read

* Write tests for image resize/clip

* Internal server error on really big image requests
  + if requested size is greater than image, just return image
  + http://sfun.elan/image/data/alice%20eve.zip/alice%20eve/alice-eve-06.jpg~args&thumb=true&maxwidth=4250

* Add FileReader, then MetadataFileReader, then CachingMetadataFileReader
  + but only after we've made the current read work
    + unless we're refactoring in the wrong direction

* Make test suite work for ViewController URL transformations plus new FileReader ones
  + sort of, ok for now

* Rewrite ViewController to use FileReader

* Make Fileview work using FileReader family classes

* Try getListing on single file
  + should just return that file

* Fix zip_part being given all the args

* Make Imageview work using FileReader family

* Weed out old tests

* Deprecate old ViewController code as using FileReader instead

* Double appending filename to end of video in stats->file

* Get cache working for video

* Need to make mediacache directory for -linux install and enable for selinux

* ../ bug in splitFilePath

* write more tests for FileReader
  + crop child as well as crop parent within zip
  + e.g. http://sfun.elan/file/data/alice%20eve.zip/ is wrong

* add super-short video to test suite

* handle large images sanely

* add test to check that two different timecodes produce two different frames
  + and same timecode produces identical frame

* fix missing video thumbnails
  + it's SELinux

* add support for .png
  + process png as png, not jpeg

* mfr bug for test suite
  + whenever we open a zip
    + stats->file is the zip folder name
    + stats->name is the file name

* Nested folders in zips should be links
  + then think about collapsing

* factor out CacheHelper

* Reading all the files for resolution/shape is too slow
  + introduce caching by default

* Javascript resolution check and class apply
  + x-bound and y-bound
    + have temporarily disabled cache to apply this
logic check
cr/ir
portrait container 200x300 ratio = 2/3 = 0.66
wide image = 300x200 ratio = 3/2 = 1.5
bound, 0.66/1.5 = 0.4 = <=1 = x

portrait image = 200x300 ratio = 2/3 = 0.66
bound, 0.66/0.66 = 1.0 = <=1 = x

v-portrait container 150x300 ratio = 1.5/3 = 0.5
bound, 0.66/0.5 = 1.33 = >1 = y

v-wide container 400x200 ratio = 4/2 = 2.0
wide image = 300x200 ratio = 3/2 = 1.33
bound, 2.0/1.33 = 1.66 = >1 = y

square image = 200x200 ratio = 2/2 = 1.0
bound, 2.0/1.0 = 2.0 = >1 = y

portrait image = 100x200 ratio = 0.5
bound, 2.0/0.5 = 4.0 = >1 = y

* not 100% on mini-pictures in folder
  + probably 20%

* folder image and overlay
  + small image alignment

* 100% height on directory background
  + if that's possible

* send out transparent gif/png for missing previews

* strange thumbnail zooming thing
  + thumbnails getting big and blurry
    + because the point we store back to the cache is after cropping
    + change mfr->cache() call point or add clipwidth/height to cache keys

* every page is too high
  + being given a redundant vertical scollbar
    + try making Symfony use production version

* image vertical centering

* back to directory view doesn't bound images properly
-- same as --
* javascript image classes failing
  + works on refresh, but not always on first load
    + disable caching to debug
      + doesn't happen reliably, needs more investigation

* javascript re-assess x-bound or y-bound on resize

* tweak sfac on js y->x scrolling

* set screen-x/y as percennamee
  + covers pre-update scenario to fix quirky drags
* check chrome re-bound

* mac dragging around the edge messes up sideways scroll
  = solved by stopping bubble

* Either move $this->stats down to MetadataFileReader
  + or rename as AwareFileReader
  = refactored, much neater now

* Convert args to object

* Don't cache error img
  + test suite failing because error image comparison fails

* Repeated vertical (flow-y) resize toggles between rows
  + slightly funny stuff going on
    + jitters between 2 and 3 rows
    ? could be finding a % in the id because we set one?
  + test drag behaviours
  = not perfect, but good enough

* Windows test suite errors

* Re-do folder from ai to produce authoritative psd
  = not psd, but exported from ai

* Debug image
  + turns out to be a artefact of an image -> in a zip -> in a shared folder
    + equally only applies to thumbnails (which is very strange)

* Create a test share and mount it into the structured tests directory
  + that way it should never affect users
    + and can provide that

* Folders on dark background

* Folders (part 1) maintain square aspect in landscape cells
  + fix positioning

* Fix nasty selection bug
  = test, done I think

* Producing two cache entries for a single image
  + don't save to cache if this image was loaded from the cache
    + ah ha, might be already protected for that
    - mmm, not
  = fixed by ensuring that we don't always generate a new cache key
    + which isn't necessary when rewriting from the cache

* Cachekey not set for directory listing
  + except first entry
  + cache is being used for all the images
    + but for some reason their cachekey isn't making it into the directory listing
    + that may not be a problem, but worth investigating
  + this is true for both zips and normal directory listings
    + it means we're not finding cached entries
      + which in turn means we never fetch metadata for dir entries
  + actually weren't putting any cachekeys in
    + trick is to use the right cache key
      + always the one for the file in situ, not in the cache
  + right, now we're getting different cachekeys because
    1. actually image is a restricted thumbnail, so uses args
    2. is just an image path, so has no args
    + verify that's true

* Clean up metadata that gets stored in cache files
  + don't need all the spurious stuff
  + rewrite names
    + width_original
    + height_original

* Think of a way to store data-native-width and data-native-height in the cached image metadata
  + worth finding ways to store and retreive image metadata anyway
    + plus it enables re-res
  + start with cache function
    + write in native-width/height
* Use cached data to write native width/height into data fields

* Round newwidth/height

* Fix test suite errors

* write getFilename and getFullname tests for test suite
  + important to have a record somewhere of what these functions should return

* video thumbnails need metadata too

* bug
probably caused by
http://sfun.elan/image/data/alice%20eve.zip/alice%20eve/alice-eve-jiggle-ibbZy7SI8fCxXB.gif~args&thumb=true&maxlongest=200&
http://sfun.elan/file/data/alice%20eve.zip/alice%20eve/
getimagesize(): Read error! in /var/www/git/github.com/structuredfun-linux/structured/htdocs/src/Lightenna/StructuredBundle/DependencyInjection/CachedMetadataFileReader.php on line 194 
+ cache is producing bad gif
  + need to make it produce a gif, but a wrapped jpg

* test out showing display-size in imgmetric in js
  + then come back to html

* get relative position of image within parent container
  + then apply to imgmetric
    + parent container is shared parent of both img and imgmetric
  = did using absolute coords
    - relative (using jquery.position() instead of offset) doesn't put it anywhere close

* bug: imagemeta is requested for each image twice
  + look at Firebug Net tab

* bug: imagemeta doesn't request images at right (bigger) size
  + got to sort of pass waitForLoad right through the chain

* use js to re-write all image URLs to local hashbangs
  + indirect via a handler rather than rewrite

* right-arrow, down-arrow
  + go one frame right

* click goes to flow-1
  + and jumps to that image

* firefox scaling factor
  + for scroll-x

* re-res directory thumbnails as per normal images
  = decided not to re-res for jq load
    + but have improved res to 200px

* title on folders

* get state in one place
  + URL: breadth, image seq, direction
    + fall back to HTML if not set
  + make nice functions that cascade
  ? do we want to cache in javascript?
    ? could this be a good time to embed a framework?

* back to page without explicit breadth
  + needs default

* clicking on an image pushes state
  + but it should only do that if the URL is different
  + otherwise the history queues up with duplicate entries
    + which makes 'back' confusing

* imageAdvance crashes browser

* need to detect if next/previous pushes us on to a new page
  + e.g. always for 1 up
  + only scrollTo() if advancing to new page

* scrollTo breaks click
  + advance to a high image
  + go fullscreen
  + advance a few more (to about 3rd or 4th)
  + go back to b2
    + think this is just like the upper end crop

* 1 minor bug in linux test suite
  + also just 1 (same 1) in windows

* reduce apache to 2 concurrent threads
  + should never use more than 2 cores
    + see if that helps with the responsiveness of the page
      - otherwise may need to use blank images
  + working for windows
    + not going to apply to linux config because we don't have the same whole-app

* time for a front-end test suite
  + introduce a basic QUnit
  + introduce a #test
    + as a new button for the header in its own file
  = half way through this
    + press on with mustache template

* return jumps back to previous image
  + but doesn't always go back to
  + seems to work ok
    + will revive if I can replicate again

* arrows get stuck sometimes
  + seems like history.js is playing up
    + get strange behaviour with advance (+/-) where it won't go one direction

* advance should wrap around

* after a click, need to focus on an element so we get keypresses
  + try jquery focus
    - it's not a focus
    + left and right arrows work, but return does not
    = just needed a preventDefault to stop the return triggering a URL refresh

* ctrl+home/ctrl+end

* scrolling needs to advance seq selection to the right image
  + important because we can't use page up/down or arrow keys after scrolling

* resize (refreshCells) event in Chrome
  + creating a new image and then measuring its width and height doesn't work
    + ix = iy = 0
  + solved by using an onload

* probably need to invest time in the javascript test suite
  + I keep exposing stuff that doesn't work on my non-test browser
    + once I've started it will flow
    = got something started

* only swap out visible images
  + swapping them all is too intensive
    + probably should try to avoid going over about 50 x 1000
      + add as line in config file
  + made progress on this
    + may return to it

* checkBound is now async
  + we need to do all the async stuff before trying to do the sync stuff
    + build a loaded image size map on image reload
    + build a cell size map on window resize
  + it's another level of complexity
    + it means we're partly reliant on the DOM, partly on js proxy objects
  + this is important
    + we need to get some kind of promise setup

* work on page load speed
  + currently reloading all images (from cache) on every checkImageBounds
    + solved using test

* first load (uncached) makes a mess of image bounds
  + it's because we've not got a loaded-width/height

* imgmetric scattered all over the page after switching from b=2 to b=1
  = ok for now
* current loading 250s en route to loading 500s
  + suspect it's to do with image bounds
  = ok for now

* extra scollbar, bit too much margin somewhere
  http://10.12.1.160:8097/file/data/alice%20eve.zip/alice%20eve/

* protect handler_scroll from itself
  - I think it's getting stuck searching for img.visible when there aren't any
* handler_scroll shouldn't be called when the page loads

* need to add scroll handler
  + at the moment we trap against mousewheel
    + but it's possible to drag the scrollbar

* setVisibleByScroll
  + tricky
    + can't quite decide if it should just scroll and
      + let the scroll handler sort out all the image
    + I think yes

* sort of moving everything out of init() now
  + and triggering hash change instead

* something is triggering a scroll event to 0,0
  + happens during page load
  + e.g. http://10.12.1.120:8097/file/structured/tests/data/20-image_folder/#breadth=2&seq=9
  + may not actually be resolvable
  = have inserted a jump-back using ignored scroll:0,0 event

* change out all the clicks to be hash changes
  = done most of them

* change image seq to entity seq
  + we want to be able to select folders
  + throws error on 
    + http://10.12.1.120:8097/file/playspace
  + because directory features in middle of images
  = not without issues but working pretty well

* change cache file extension into .dat
  + avoid mediacache leak

* test suite error
  + only occurs when running a second time
  + it's a cache error
  + need to keep hold of the original extension

* first load after cache clear
  + not reresing images
  + seems like we're not waiting for image load before firing imagemeta request

*** have set a cache clear every run! ***
  + but only from my local settings

* need to be able to merge in settings from config files

* could be double-loading the metadata
  + would explain why we're swapping out the images twice

* NaN% on certain images
  + there's an ordering of concurrent ops that allows this
  + problem is that the image is loaded
    - but the imagemeta call hasn't returned yet
    + so we're trying to compute %age based on width/height-native
    + but they don't exist yet
  = have protected
    + watch for images not re-resing

* double end doesn't work
  + seems to only be in larger datasets
    + this happens when we end up with no .visible entries
      + we do a select on a jqEnt that doesn't exist
        + protect against that
      + then fix the forward

* right arrow from sMAXb1
  + should wrap around to show s0b1
  - but get error

* Apache builds for Windows
  + http://www.apachelounge.com/download/additional/

* don't load all thumbnails in very large data sets
  + still quite slow on load
    + think js op is slow
  + also doesn't work
  + need to do it the lazy loading way
    + http://www.appelsiini.net/projects/lazyload
    + start by implementing noscript version
  = working, may need to do more

* dragging in very large image set
  - jumps back to zero every drag

* key press (like ctrl+end/home) triggers hash change
  + hash change loses key focus from window
    + need to preserve so we can 
  = seems to be working for now

* fullscreen from visible images
  + needs to refreshImage

* images not displaying
  + problem doesn't seem to be caused by the refactoring
  + the cells are slightly outside the window (top:-1, left:-1)

* move selectable, selected, visible up to cell
  + test thoroughly

* clean up isVis to make it reliable for on-screen

* fix end bug

* fix test suite
  + end doesn't select last entry
    + it's toggling between 838 and 836
    + which I think is caused by isVis getting it wrong
      + test using #!seq=8
    + do it properly with unit tests
      + tricky to test
    + best to do it with the test suite

* extend test suite
  + test visibility
    + scroll to start, scroll to end, scroll to middle
    + test all visibles in one block (no littering)

* extend test suite
  + test reres
    + reres of first x images

* need to work out how to handle tests keyed upon delayed events
  + deferred promises are the way
    - but passing them around is tricky
  + either parent thing can make a queue
    + and pass it to all the sub functions
  + or originate in each sub function
    + and then aggregate queues in parent functions
  = brilliant piece on deferred patterns
    http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt2-practical-use

* fullscreen of image 0 needs to hide all imgmetrics

* fullscreen/return should toggle
  + between b1 and bPrevious

* changing from b2 to b1
  + need to do another refreshCells at least on current image
    + because cell shape may have changed dramatically

* reload page from final entry doesn't swap out images properly
  + seems not to be loading thumbnails
    + so the 500 request doesn't get any metadata

* arrow-key / home after scroll

* pull forward UI test suite

* rewrite isVisible function to cope with partials
  + frequently images are partly on screen
    + but not treated as visible

* dropping back from fullscreen, checkImageRes swaps out all the images
  + not just the visible ones
    + this is all to do with async stuff
    + we need to wait for the hash updates to complete before doing a checkimg

* not loading right image just in time
  + in fullscreen mode
    + loading one image behind

* this test suite stuff is so important
  + I've just recovered from breaking it
    + a break that wouldn't have occurred if I had a reliable test suite
    + and could have been hunting for regressions all the time!

* re-write hashTable using Object.create
  + put in separate file for now
    + can aggregate later
  = thought better of
    + not enough instantiation to merit prototypes


* force imagemeta to return meta

* modify the numbEventQueue to be deferreds manager
    + that's a pretty good handler
    + needs a hash (string), done function pointer and parent
  + looking pretty good
    + need to find a way to pass deferreds through the eventQueue
      + will circle back to this once we've got deferred cascading through the actual event handlers
* expose deferred through exported API
  + need to create deferred first
    + then pass into following event handlers
  + so we can queue up dependent functions
    + like the test functions
  + we get into complications when we're trying to push a deferred through a hash update
    + there are potentially many layers
      + one hash update, triggers scroll update, triggers hash update
      + nice to great some kind of general rule
  + how about eventQueue for storing the deferred
    + create when eventQueue item created
    + pick it up in the handler
      + could even link up parent events
        + done when say setScrollPosition called indirectly by a handler
  + maybe it's a combination metaphor
    + we need eventQueue to bridge between code->handler
      + because it's async
    + how to do parenting
      + class-wide var is complicated because it could get messed up
        + it's analogous to the old-school global variable
      + passing deferred from function to function requires care
        + it's going to need elaborate lacing together
        + could pass event object around
  + making eventQueue fairly smart
    + tries to wrap up as much of the promise logic as possible
      + because then it's all in one place
        + if a 'parent' set it does get resolved once its child is resolved
  - beginning to wonder if the necessary deferred tree will be just too complicated
    + it reaches through almost everything
      + might need to rewrite most ops as synchronous
    + not sure
    + using the #hash is elegant
  + eventContext originators
    + fire_
  + eventContext decorators/ornaments
    + everything else
  + eventContext resolvers
    + terminals that create a local context and resolve
  + execution summary
    To numb a listener, at the point we decide to numb it
      eventQueue.pushChild(eventContext, { 'replaceEvent': function(){} })
    To pass a context on, which may have been numbed upstream
      eventContext
  + what about passing
    + everything we pass it into
      + needs to be able to pass it out?
  + check the event story
    + fire_scrollUpdate creates eventContext(1)
    + handler_scrolled receives eventContext(1)
      + calls refreshVisibility with same context(1)
        + refreshVisibility doesn't do anything async itself, so no forking
        + calls setVisibleAll with eventContext(1)
          + calls setVisibleImage with eventContext(1)
            + calls refreshImage with eventContext(1)
              + calls refreshBounds with eventContext(1)
                + calls getLoadedResolution with eventContext(1)
                  + creates it's own child eventContext(2) using pushChild
                    + sets up stuff to happen
                    + returns eventContext(2) so that parents can queue up other stuff for AFTER this happens
                    + when stuff happens the child resolves (eventContext(2) resolves)
                    + the things that the parent queued up start getting executed
                  + returns eventContext(2) if it scheduled stuff, or eventContext(1) if it didn't
                + refreshBounds then queues stuff against the eventContext it receives (2/1)
              + refreshImage then queues stuff against the eventContext it receives
  + remember
    + pushChild only when we're about to WAIT for something to happen (e.g. an actual async wait, e.g. image load)
    + .then to setup things to happen in sequence
    + can normally chain execution with .then()
      + only need to create a new context when
        + waiting on something unpredictable
        + OR MAYBE when doing multiple things
  - not sure about pushChild needing to 'resolve' the parent
    + think it's probably a yes
  - not sure about how to execute multiple things in sequence
  + not currently preserving eventContext across checkMetadata
    + that a bit is deliberately async-unsync
  + everything is stacking up on the eventQueue
    + seem to be resolving <unset:2> several times over
      + could be because 2 is everything's parent
  + problem is that we're stacking all the eventContexts in series
    + there are some that are event dependent
      + which means they can resolve at any time
        + which means the middle of the chain resolves
    + need to create contexts for each event-dependent event
      + then do some kind of aggregation to say 'wait for them all to finish'
    + eventContext:parent is used to kick the parent
    + eventContext:deps is used to store a list of all the contexts we depend on
      + everytime the parent gets kicked
        + it checks to see if all the deps have been satisfied
    + if there are no deps
      + it resolves right away
    + I get foggy on the different situations this can come up in
      1. do something in a child function, when it's done, allow its parent to be called
      2. ? is there a 2?

* add class nearvis
  + add to it 2x breadth on either side nearvis

* look over remaining eventContext vars

* need to expire unmatched scroll events
  + mouse wheel produces lots of scroll events
    + they hang around in the queue indefinitely
    + could expire after 1 second
      + because the gap between scroll and handler shouldn't be more than that

* think about buffering scroll events
  + handler_scroll
    buffer (function(){}, 50)
    + could return using a deferred
      + like a deferred, simple
        + but we have to be careful because 
          + there could be queued eventContexts interleaved with random scroll events
          + each one of those eventContexts needs to get dealt with
    + could return doing something clever with the invented context
      + could pushChild each context
        + so that once we complete the last one
        + we also complete all the others

* rebound/x-bound on 305 at fullscreen

* only show imgmetric when image has re-res'd

* smooth scrolling on trackpads
  + can't differentiate trackpad,
    + but can do smooth scrolling on variable
    + could make it an option

* synchronicity
  + waiting on all getImageMeta/metric pos to complete
    + before re-resing all
      + before updating
  + ideally want things to only aggregate at highest level
    + so that each thread can keep the pipefull
  + not important now

* refactor eventContext stuff
  + I'm not going to want to do it
    + but go back in, test alternatives and clean-up eventContext stuff
    + there are too many unanswered questions
      + and I'm sure I can make the syntax easier
  + started already
    + straight deferreds are the way to go
      + maybe just use eventQueue to handle the link between fire_ and handler_
  + question: how do we handle events we're trying to nullify
    + search 'replaceEvent'
      + refreshSelected / imageAdvanceTo 
  + question: should we sometimes resolve deferreds only after the handler fires?
    + like
      + fire_scrollUpdate
      + refreshSelected / imageAdvanceTo 
    + risky?
      + maybe
  + some contexts contain deferreds that are getting resolved
    + but the eventContext never gets removed from the eventQueue
      + while it's there it could potentially interfere with other queued eventContexts
      + need to remove them
        + try and use the eventQueue to resolve
          + because then the resolve can also remove from the queue
        + that requires that events can identify themselves to the queue
          + and say 'delete me'
        + best place to handle that is in hashTable
          + which means moving evid (eventQueue) to id (hashTable)
  + unfilled get requests are fine most of the time
    + they don't accumulate which is great
  + having some issues getting events to resolve all the way down the chain
    + try from api_ call and work backwards
      + carry on with this!
    + it is resolving, but only after 10s expiries

* optimise dragging in large image sets
  + implement vistable
  = it's very fast now

* refresh vistable on breadth/direction change

* viewing images fullscreen broken
  + suspect it's related to refreshing vistable
    + some work ok,
    - but not seq=0 or seq=1
  + no images are flagged as visible

* vis missing one image
  + /file/structured/tests/data/20-image_folder/#!seq=9
  + it's because we're hitting minref = maxref = ref 5
    + when ref 4 has the same value
      + need to always work backwards to be sure
    + needed a work forwards (like work backwards)

* nearvis isn't always right
  + in small image sets
    + good in large sets
  + need to remove nearvis
    + or rather rename nearvis once it's no longer near
  + better, but still too much nearvis in image_folder dataset

* too many visibles
  + seq=0 showing 8 & 9
    + should stop at 7
  + fixed with rounding = 3

* can scroll selected image off-screen
  + updates hash but doesn't update selected

* end, fullscreen, home
  + check re-res

* page up should eventually move the selection to 0
  + page down should eventually move to end

* imagemeta/ endpoint should always get image metadata
  + at the moment it only produces good metadata for pre-cached images
    + if we discover an image uncached
      + we should cache it at standard thumbnail size (longest edge 200)
        + most cache requests comes in 

* treat direction as another piece of hash state
  + where a hash value is the same as
    + NOT what's in document 
      + because it changes
    + the default value from the last page load

* res change needs to fresh metric positions
  + could tie that into refreshCells

* accelerate scroll catch-up
  + working but needs to be quicker
  + may need new async/promise trick

* home/end stalling
  + need to protect fire_hashUpdate
    + when firing will never trigger the handler_
      + i.e. home when at seq=0, end when at seq=last

* thinking about splitting the metadata store off from the mediacache
  + it's not without its complexities
  + the problem arises because we cache an image like thumbnail?maxlongest=200
    + I think it's reasonable to ask for image metadata for the same size
  + have found a workable solution for now
    = will delay decision for now

* border 4px on .cell a
  + once alignment is working

* cell resizing complexity
  + normalise heights at current width
    + work out proportion
      + that is the height at the point where this image becomes x-bound
    + trim the waste
      + leaves waste top and bottom
    + need a width which 
* need to refresh visTable only cellRefresh done

* introduce (!reloaded-width) data-ratio
  + updated everytime we load an image
    + loaded width is only updated the first time
  + addresses basic wobbles
--o--
* cells jigging about
  + gonna try not updated loaded-width
    = introduced ratio which stabilised them

* scrolling through directory is jumpy

* refreshCells is tricky
  + we really want to do it once
    + but at the moment we refresh each image (refreshImage)
      + and within that refresh its bounds
    + we need all the bounds back
      + to get the imageContainer sizes
        + to work out the free space around each
          + to average across a row/column
            + to resize the cells
              +++ to set the new cell sizes
                + to read back the new sizes
                  +++ to request the new resolutions
    + can't check bounds until all the images (thumbnails) have loaded
    + we will work through the images in order
      + but they'll load out of order
        + so we're going to struggle to get the rows
      + could break refreshImages into two phases

* need to wait for nearvis to be loaded
  + before trying to resize their cells
    + thinking about coupling all cellResizing to image loading
      + as soon as thumb loaded, it stays loaded
      + thumb loading
        + stores loaded-width
        + triggers attempt to resize cell
    + thinking about these things in cell singles/pairs/quads/octs
      + known as minorGroups
      + every load event checks its minorGroup
        + e.g. column for x-major, row for y-major
    + means that we're not formally doing a cellresize on all visibles any more
      + instead we do a resize on a single/pair/quad/oct because it becomes visible
  + this takes us back to hashTables
    + ideally want to preserve bucket information in visTable
      + and be able to update singles/pair/quad/oct (SPQO) easily
        + without having to rescan the whole lot
  + currently the whole vis chain works to a single set of functions
    + making this easier to change
  + however the resize event is important here
    + when we resize at 0
      + everything works beautifully
        + because there's no width change in anything prior (off-screen left)
    + when we resize at 500
      + everything jigs about horribly
    + we're trying to get to the point where
      1. resize @0 works
      2. scroll backwards and forwards works
      3. resize @500 works
    + that leads me to think
      + never change the width of an off-screen element prior (left or up)
        + that includes nearvis
      + probably keep processing cellresize in large batches of visible images
      + if we do have to adjust a prior cell width/height
        + always tweak scroll position to compensate
          + that's probably tricky to do surruptitiously
      + don't strip all previous width/heights
        + except on repaint event
          + and even then I'm not sure about it
      + series of fixes might be the best way to counter it

* forward scroll nearvis
  + if we try to cellresize on a cell without a thumb yet
    + it probably won't have a ratio
      + which returns a NaN problem
  + insert a getLoadedResolution and break second part into callbackfi
    + could make cellResize resolve a deferred
      + could make refreshImageResolution dependent on it
      + in fact should do that
        + but may still process 'nearvis' as async
        + leave as async
      + can make something async in one thread
        + and resync in another
          + the image loading lifts all boats

* big picture goal
  1. resize @0 works
  2. scroll backwards and forwards works
  3. resize @500 works

* forward scroll nearvis
  + shrinking visibles brings new 'nearvis' into view
    + need to make them visibles too
  + part of the process needs to expand the 'vis' selection
    + that also means expanding the nearvis selection

* vertical scroll doesn't work nicely yet
  + it's something comparatively simple
    = * instead of /
      + affected by alignment bug as per horizontal

* alias .sfun as this.containerName

* cell sizes jigging around
  + high seq numbers do 2 draws
    + first looks pretty good
      - but 2nd is weird
    + it's not the reresing
    + it's not resetting ratio
  = pretty sure it was a mixture of x-bound and y-bound

* changing breadth, direction, viewport size
  + needs to clear cell-specific percentages
    + then re-apply them

* even up border all the way around
  + actually important to cue which way the there's more content
  + margin-top: -8px lifts everything up
    + almost there, but we're not quite
    + right hand edge doesn't get thing
  + horizontal
    + need border on right hand edge
  + vertical
    + need border on bottom
  = don't worry about it for now
    + will have to insert an additional element

* chase down the NaNs
  + they're a lead
  + good debugging url mb@seq=288
    + debugging is hard
    + it's to do with an out-of-order execution (OOOE)
      + stepping through in a debugger doesn't find it

* perc's are not showing
  + but only for the latest batch of loads
    + old (but still visible) images lose their perc
    + it's because they're being left in a 'reresing' state

* introduce idea of partial visibility
  + sometimes we want the test to include 'partials'
    + e.g. 'visibles'
  + sometimes not
  + suggest we introduce 'partial'
    + rename nearvis as visnear
    + introduce vispart
    = it is now possible for there to be no 'visible' images
      + only vispart, but that's ok

* split structured.css from structuredfun.css

* reload on page with #!seq=0 (or just #!)
  - doesn't load images
    + seems to only load images if seq > 0

* reload on page with #!seq=0 (or just #!)
  - jumps to seq 5
  + even on mas it's doing to same thing (0->2)

* can't select seq for vispart
  + i.e. seq > visible

* vispart doesn't work on first two images

* jump straight to cell
  + e.g. seq=17
    + this is being killed by the scroll0,0 browser glitch
  + event order
    + handler_scrolled to #seq-17 (cells unresized)
    + handler_hashChanged seq=17
    + handler_scrolled to 0,0
    + handler_hashChanged seq=17 (doesn't see anything changed)
      + shouldn't do a refreshVisibility because we're looking at the wrong range
      + instead we need to make it realise seq has changed
        = done with a forceUpdate
  + at handler_scrolled to 0,0
    + need to default-out all the state
* a [breadth change] click seems to fire hash change seq=10
    + then fire hash change seq=10&breadth=1

* jump straight to cell for b1
  + e.g. breadth=1&seq=17
  = also fixed with forceUpdate

* high seq clicks (b2 to b1) jump back to seq 0
  + tricky
    + breadth change clears cell width/heights
      + which is good because we don't know where they're going to be
    + if we go to where seq 10 is now
      + the cellsResize will move it
        + so we end up seeing seq > 10
    + this also triggers hashChange trickle from seq=10 to seq=12
      + because 10 is only partly visible (vispart)
--o--
* can replicate exactly same issue
  + jump to high seq
    + then left arrow down through seqs
      + spacing whack
        + so we end up in the wrong place
  + need to work out exactly what's happening
    + because preseq images don't appear where I'd expect them
--o--
* develop a preseq spacer
  + as we're resizing cells to the left/above seq
    + insert a spacer at 0
      + then yank it out and move the scrollbar to compensate
  + a spacer may not work
    + because sometimes the preseqs are _wider_ than before
      + so we need a negative spacer
    + best done as a negative left/top on the ul.sfun
  = pretty good, bit of jitter but ok

* trigger redraw on offseq change

* scroll0,0 can arrive before or after scroll 32418
  + before is fine because it manually triggers handler_hashChanged again
  + after is a problem that means we render 0 instead of high seq
    + also the actually scroll to 0,0 can happen in the middle of our execution
  + need to capture the document scroll position at the same time as making the isVisible decision
    + not quite isvisible-time
  + seq106, 18851 + 839 = 19690
    = postponed, ordering not clear yet

* end key isn't returning at load completion
  + it's also jittering its way down from the last screen
  + seq 0 does now return properly

* nullify scroll0,0 not resolving at the time
  + it only gets cleaned up much later
    + can we resolve it as soon as it's nullified?
  + it's not that the nullified scroll0,0 event doesn't get resolved
    + it's that the nested handler_hashChanged event doesn't
  + there's an ordering issue
    + sometimes the scroll0,0 comes before
    + sometimes it comes after
  + this could be to do with the buffering of scroll events
    + we get a scroll0,0 and a real scroll very close together
    + try not buffering
      = have disabled buffering
  + parent (scroll0,0) is resolving before child (hash:seq208)
    + child effectively gets orphaned
      + but child is independent of parent
      + so it shouldn't matter
    + handler_hashChanged times out
      + profile every stage of the hashChanged
      + I think it's because we end up firing two hashChangeds with the same key!
      + doesn't seem to be an issue, but will follow
  + could repurpose event queue as list of all outstanding (unresolved) deferreds?
  + handler_hashChanged creates/picks up context
    + needs to pass it down to fire_scroll to get to handler_scrolled
      + I think that's why parenting is important
      + don't think we need to parent
      + because parent has a .done() waiting on the child
        + then parent will resolve itself
  + alsoRemove = false
    + that way we only remove things from the event queue once they're resolved
    + this is slightly more complicated
      + we sort of need two queues
        1 for unresolved events
        2 for unhandled events
          + these are fired events that have yet to be handled
          + we need them to be handled only once
            + but they may take a long time to get resolved
            = pending
    + make mergeOrPush look for an existing entry in the unhandled queue
      + this is worth doing
        + because at the moment two handlers can resolve the same single eventContext
          + leaving some contexts unresolved
          = come back to this
  + I think we're creating the 0,0 scroll events
    + example doesn't experience any 0,0 events
      + http://www.lightenna.com/staticpages/jsfiddle/hashseq/index.html#!seq=14
    + test: try and remove all the scrollTop calls for now
      + didn't make a difference
  = drowning in complexity, need to simplify

* build jsfiddle demo of basic setup
  + move fiddle to htdocs root
  + work out what causes the scroll0,0 event
    + vertical scroll fine
    + horizontal scroll fine
    + libraries ERROR
      - turns out it was the QUnit library

* it's time to tear out and refactor the hash changes
  + start by pulling out the init stuff
    + just attach the hash listener and see what it's like
    = works ok, but reload problematic
      + QUnit!

* new idea
  + always draw page-0
    + then jump up to page-X
  = abandoned for now

* straight jump from high-seq to low-seq (not reload)
  + seems like we're catching the position too late
  + or not locking the position early enough
  + there are two routes through a handler_hashChanged
    + setScrollPosition, which triggers other stuff
    + refreshVisibility
  + it's not the clearest split
    + really need to nail those two cases
      + and come up with a clearer definition of how they're different
  + test cases

    + cold load 0 = fine
      + handler_hashChanged(seq=0 or '') from init()
        + noChanges:refreshVisibility
          + setVisibleAll
          + refreshSelected

    + cold load low seq = fine
      1 handler_hashChanged(seq=6) from init()
        + seqChanged:setScrollPosition(931,0)
     2a handler_scrolled(0,0)
      3 handler_hashChanged(seq=6, forceUpdate)
     2b handler_scrolled(931,0)
      4 handler_scrolled_eventProcess(931)
        + images appear
      5 handler_scrolled(557)
      6 handler_scrolled_eventProcess(557)

    + cold load high seq = fine
      1 handler_hashChanged(seq=208) from init()
        + seqChanged:setScrollPosition(32418,0)
    [2a]handler_scrolled(0,0)
    [2b]handler_scrolled(32418,0)
      3 handler_hashChanged(seq=208, forceUpdate)
      2 handler_scrolled(32418,0)
      4 handler_scrolled_eventProcess(32418)
        + images appear
      5 handler_scrolled(31919,0), nullified
     10 nullify scroll0,0 setScrollPosition

    + load 0 skip low = fine
      + handler_hashChanged
      + handler_scrolled

    + load low skip high = workable problem

    + load high skip low = same workable problem
      1 handler_hashChanged(seq=6) from init()
        + seqChanged:setScrollPosition(931,0)
     2b handler_scrolled(931,0)
        + images appear
      3 handler_scrolled_eventProcess(931)

* turn off JS
  + work on no-js version
  + disable js all together to see what it looks like

* run tests from htdocs directory
  phpunit -c app/

* cached images not writing x-bound/y-bound
  + injectargs is injecting them too late
    + well after we've used getOrientation

* images with IPTC special whatsit create error

* alignment of menu icon

* make sfun header expand on hover using CSS-only in non-JS version
  + actually all the header actions require JS
    + so better not to show menu at all

* create hamburger icon for sfun header

* no-js or disabled-js
  + show all the thumbnails
  + no-js uses noscript alternative
  + disabled-js will have to manually flip them in
    + done in its own if clause

* cold load seq=1 doesn't draw anything
  + cold load seq=0 doing the same

* load of top-level container

* pass .selected in with range

* update vistable after cellsResize
      // update vistable
      // @todo should do this more selectively
      that.visTableMajor.updateAll(direction, $sfun_selectablecell);
      // use updated table to check visibles, but don't also tell then to reres yet
      that.setVisibleAll(false);

* need to check ratio (and therefore bounds) for range before calling flow_resizeCell
    for (var i = 0 ; i<bucket.length ; ++i) {
      var jqEnt = bucket[i];
      var jqBoundable = jqEnt.find('.boundable');
      if (jqBoundable.data('ratio') == undefined) {
        // wait for image to be loaded in order to get ratio
        defs[defs.length] = this.getLoadedResolution(jqEnt).done(function() {
          that.setBound(jqEnt);
        });
      }
    }

* split out layout engines
  + few options for how to implement these
    + using hooks
    + extend the sfun object
  + api is elegant and gives us abstraction
    + it's quite hard to split out cleanly
  + extend is good, but it keeps everything functional
    + which itself has issues
    + growing complexity of structured.js is a problem
      + proper abstraction is maybe a bit harder to code for
        + but it does give us a proper ADT
    + this is a pretty good way of developing an API architecture
      + I'll learn from that
    + API is a two way issue
      + we can move all the functions out into an object
        + and they need to be able to call out library functions in sfun
      + but we also need call points in
  + interesting question about pre and post activities
    + post update vistable makes sense
    + what about a pre-getLoadedResolution and setBound?
      + sort of yes
      + we don't want to have to load all the images
        + but it seems reasonable to ask a layout engine to layout cells
          + only when it knows what's in them
  + working, but need to finish parse of structured-flow.js
    + setBound
      + sorted
    + checking others

* compute ratio in html (using cache) if possible

* little bit of fun working on optimisation
  + reducing js load
    + Chrome profiling is most accurate

* directories in the middle of a set of images
  + breaks next image on to new major (row/column)
    + so following image ends up at 100% minor axis
  + could just push all sub-folders to the end
    + consistent with OS behaviours
  + also a chance to sort (ha!) non-images at head of directory

* disable flow for testing
  + resizepending never gets cleared
  = no longer gets set

* order
  + handler_hashChanged
    + [handler_scrolled]
  + refreshVisibility
  + setVisibleAll
    + loadThumbRefreshBounds
    + cellsResize
    + refreshImageResolution
* key points
  + cellResize has to have cell size and ratio only
    = have multi-streamed
      + now runs at same time as loading the thumbs

* blurring of first two images in HP set
  + this is to do with the execution order
    + when the thumbnails are cached
      + ratio gets loaded by the html
    + we do a cellsResize
    + not sure why that loads some very low-res thumbnails
      + [viewport] resize is fine
    + only seems to be the first load
      + and only then of cached images
    + doesn't seem to happen when we pause in debugger
      + suspect we're reresing before the thumbnail loads
  + it's not the first two images
    + it's the portrait images
      + because the cell height is tiny (35px) before image loaded into it
    + try suspending the bound
      - nope, same deal
  + there's a tension between cellsResize and loaded-width
    + the point of pushing loaded-width and ratio out in the html
      + is to make the page loading faster
    + if we have to wait for the thumb to load
      + in order to decide if we should reres
      + we might as well not push the loaded-res out with the html
    + we can still send the native-res
      + which means we won't have to do a imagemeta api call

* detect whether visible boundaries have changed at all
  + use to decide if cellsResize should go on to call reres
  + crude optimisation, but effective

* folder images are loaded before everything else
  + they're currently loaded with src
    + use desrc instead
  + may need another class or
    + need to consider how we currently select images for desrc->src'ing
  + aiming for same recursive structure
  + work on bounding

* make flow resize directories first
  + then stick the crucial details on the outer li
    + e.g. ratio
  + so that the main resize will correctly proportion the cell
  + set the ratio on the parent
  + can't take the ratio from the ul
    + because it's expand-to-fit
  + need to take it off the actual images

* test removing width:100% from flow-pc > .cell a
  + seems to bring the whole image back in view
  + sort of fine but it creates some alignment issues under flow layout
    + could be caused by flow not calculating widths/heights allowing for margin
      + creates case where dimensions are off slightly
      + which is why part of each image gets lost

* experiment with direction=y
  + direction-y is broken
    + it's loading all the images
  + all images are getting set visible
  + simple to start with
    + not setting flow-y on html

* images above (in direction=y) are being given visnear
  + but should show be vispart
  + setVisibleAll
    + vispart works forward, but not backwards
    + need to backtrack through previous visnear to find ones that are vispart

* vispart on first load
  + showing up as vispart images not reresing
  + think this might have been the vis problem
    + stowing for now, will recreate if rediscovered as an issue

* margin problem
  + margins + 100% create cropped images
--o--
* losing a bit of the image
  + shows up as mc yellow border missing
  + also pink highlighter gets lost on bottom/right edges
  + related to margins
  = margins looking great
    + flow layout will need work to accommodate

* adapt flow layout to new calc'd margins
  + alley set properly too

* experiment with alternative breadths
  + broadly ok
    + breadth 1 has a shuffle
    + no
      + there is a shuffle, but it's unrelated
  + 2 and 4 tested fine

* offseq breaks preseq fix
  = re-test
    + seems fine
    + chrome issue is separable

* re-enabling buffering doesn't work
  + it doesn't load any images
    = fixed, bad name

* little optimisation cycle
  + concentrate on scroll and click
    + refreshMetric

* all cells are broadly the same size
  + so after one cell has upped its resolution
    + we should remember that and use it as the default thumbnail size
    + which should mean we can skip refreshResolution
  = worked really nicely

* image thumbs are loaded by two means
  + setting an image as visible loads it thumb (always)
    + I suspect we should only do it for visible/vispart
      + that way we can delay visnear to later (refreshImageSet)
      + by which time we may have set lastMaxLongest
        + which means visnear images get the correct size right away
  + refreshImageSet loads the thumbs
    + but it does it better
    + by doing it for the visibles first

* scroll:x=4 for first image
  + because first cell now lives at 4px
  + best to allow for the -4px

* need to somehow store the function that we will execute in the actOnEvent clause

* when we resolve an event
  + see if it has a parent
    + if it has, make that the criticalSection
    + if not, make criticalSection = null

--o--
Example 1: created by entering seq=20 url into new tab
o unfilled get request for key[hash:seq=20] structured.js:2114
+ pushed event context[undefined:hash:seq=20, pending, invented context for handler_hashChanged], qlen now 1 structured.js:2012
> entering critical section for undefined:hash:seq=20, pending, invented context for handler_hashChanged structured.js:2195
+ pushed event context[undefined:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate], qlen now 2 structured.js:2012
* fired scroll event 1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate structured.js:2373
- pulled event context[1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate], q2 structured.js:2112
 - pulled not invented context[1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled], q2 structured.js:2146
  + pushed event[undefined:hash:seq=20, pending, invented context for handler_hashChanged] has parent[1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps] structured.js:2096
_ delaying critical section for 1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps structured.js:2207

--o--
Example 3: created by entering seq=20 url into new tab
o unfilled get request for key[hash:seq=20] structured.js:2115
+ pushed event context[undefined:hash:seq=20, pending, invented context for handler_hashChanged], qlen now 1 structured.js:2013
> entering critical section for undefined:hash:seq=20, pending, invented context for handler_hashChanged structured.js:2198
- deprecated event context[undefined:hash:seq=20, pending, invented context for handler_hashChanged] in favour of [see next pushed], q0 structured.js:2045
+ pushed event context[undefined:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged], qlen now 1 structured.js:2013
* fired scroll event 1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged structured.js:2376
- pulled event context[1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged], q1 structured.js:2113
 - pulled not invented context[1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged, instead of invented context for handler_scrolled], q1 structured.js:2147
  + pushed event[undefined:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged, 1 deps] has parent[1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged, instead of invented context for handler_scrolled, 1 deps] structured.js:2097
_ delaying critical section for 1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged, instead of invented context for handler_scrolled, 1 deps structured.js:2210
     - it's parenting itself
       + which creates a stall
       + this makes sense
         + because we're in the handler_hash critical section
           + then we fire a scroll with the same context
           + when the scroll event comes through
             + it has the handler context
             + but goes through the same actOnEvent logic
               + which at the moment only sees the critical section
               = now have a detection in place to guard against this

* criticalsection code is currently [!commented] buggy
  + we get into problems when a handler_scroll is a child of a handler_hash
    + the handler_hash is waiting on the scroll
      + but we're stopping the scroll from resolving because handler_hash is in its critical section
--o--
Example 2: created by reloading (seq=20) while scrolling somewhere else
  i.e. refresh means browser fires a scrollevent for new page (e.g. scroll:x=3239) that's different from where we should be (e.g. scroll:x=3590)
--o--
o unfilled get request for key[hash:seq=20] structured.js:2115
+ pushed event context[undefined:hash:seq=20, pending, invented context for handler_hashChanged], qlen now 1 structured.js:2013
> entering critical section for undefined:hash:seq=20, pending, invented context for handler_hashChanged structured.js:2198
- deprecated event context[undefined:hash:seq=20, pending, invented context for handler_hashChanged] in favour of [see next pushed], q0 structured.js:2045
+ pushed event context[undefined:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged], qlen now 1 structured.js:2013
* fired scroll event 1:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged structured.js:2381
+ pushed event context[undefined:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate], qlen now 2 structured.js:2013
* fired scroll event 2:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate structured.js:2381
- pulled event context[2:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate], q2 structured.js:2113
 - pulled not invented context[2:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled], q2 structured.js:2147
  + pushed event[undefined:scroll:x=3590&y=0, pending, localContext for fire_scrollUpdate, was invented context for handler_hashChanged] has parent[2:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps] structured.js:2097
_ delaying critical section for 2:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps structured.js:2215
+ pushed event context[undefined:scroll:x=1484&y=0, pending, localContext for fire_scrollUpdate], qlen now 3 structured.js:2013
* fired scroll event 3:scroll:x=1484&y=0, pending, localContext for fire_scrollUpdate structured.js:2381
- pulled event context[3:scroll:x=1484&y=0, pending, localContext for fire_scrollUpdate], q3 structured.js:2113
 - pulled not invented context[3:scroll:x=1484&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled], q3 structured.js:2147
  + pushed event[2:scroll:x=3239&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps] has parent[3:scroll:x=1484&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps] structured.js:2097
_ delaying critical section for 3:scroll:x=1484&y=0, pending, localContext for fire_scrollUpdate, instead of invented context for handler_scrolled, 1 deps structured.js:2215
      + this looks like it's being caused by fire_scrollUpdate
        + that's probably scroll events coming before the handler_hash has finished
          + suggest we delay listening for scroll events until we've resolved the first handler_hash
        + now this may create issues
          + because we currently rely on the scroll handler to reposition the viewport
          + that's important when we do an Example-2-style scroll-refresh
            + or an Example-1-style initial load
        = implemented manual call

* make test suite work by dynamically including QUnit
  + then move on to eventQueue test
  = QUnit load is currently commented, because it triggers a scroll:x=0&y=0 (0,0)
    + uncommented, but delayed load until click
    = that worked incredibly well

* double loading
  + it may be related to scroll bug
    + it was for seq=0
    - but not for seq>0
  + definitely doing 2 sets of loads
    + verified in chrome
      + we do one set of loads as part of the handler_hash
      + and another as part of handler_scroll
        + this happens because Chrome sends a scroll event back to where it was before
    + firefox is harder
      + inserting breakpoints changes the way it works
      + need to prove this
        + insert console.log statements
          + to track the start of each handler_
      = proved
--o--
* critical section
  + this speaks to a wider issue of handlers firing in the middle of other handlers
    + or in parallel
  + might need to protect the handlers so they can't run at the same time
    + good opportunity to improve and extend buffer()
    + single queue shared between both handlers
      + stick everything on it
        + investigate priming events with 'donotwait'
          + so we don't introduce a universal 250ms delay
    + could use eventQueue
      + it is a queue (ordered list)
      + we've got push, could create pop
      - it's not how it works at the moment
        + the handlers_ pop by referencing a key
          + we're talking about making the handlers queue stuff
        + now they kind of do that already
          + because they create a local context
      + could setup deps
        + to make the new event dependent on the existing event one
      + the current status
        + all events get pushed on to the queue
      + the change
        + setup one event as 'currently-in-progress'
          + inCriticalSection flag on eventContext
            + use actOnEvent function as opportunity to flag it
        + modify push
          + if another eventContext is inCriticalSection
            + flag the current event as 'do-not-act'
            + make the current event dependent on the one inCriticalSection (crit-dep)
      + change seems pretty simple
        + need to understand interaction with buffer()
        + will end up adding a lot of crit-deps that simply resolve
          + but that should be ok
            + can always come back to it later
            + besides, that what we do already in handler_scrolled
    + eventQueue child -> completes -> kicks parent
      + currently can only cope with a single parent
        + if we allow multiple parents
          + we can use the existing mechanism
      + this is actually a little more complicated
        + we need to end up with a queue
          + so it's not as simple as just making all events parents of the critical
          + we need to chain them
          + this needs its own test
    + actOnContext is the right place for it
      + but there are a few different drivers
        + actOnContext needs to return true/false
        + not sure if actOnContext should resolve the deferred
          + or whether the calling function (handler_) should
          = the latter
            + it's more consistent
          + therefore return true or false
    + tricky bug may be hiding
      + if we setup replaceEvent to resolve itself
        + what happens when another event merges with it?
        = coded against it

* test whole test suite
  + work's remarkably well
    + really nearly there for iteration #1!
  + trigger key press is returning a deferred
    + but it isn't waiting long enough for the scroll event to complete
      + probably no bundling up child events
      + firefox illustrates it nicely using endkey dirty test
        + shows the right cells
          - but they haven't been rendered (no thumbs/reres/imgmetric)
      + the event log is very complicated
        + many events are getting merged
          + and somehow one it getting resolved too early
      + best way to fix it is to write the eventQueue test

* debug vistable test

* cheeky vertical scrollbar
  + sorted with calc() again

* write eventQueue test
  + need to test child resolving kicks parents
  + this needs to be thorough
    + there's now a lot of complexity in there

* test replaceEvent scenarios

* test actOnContext

* setBound on nearvis [async] after doing everything else
  + may need to disable caching to test it
    + because at the moment we push bound out with the HTML
  + can't be sure, but it looks like we're setting it already
  = investigate in really large image set (MB)
  - don't appear to be loading nearvis at all
    + we are actually loading the images
      + but we don't seem to be swapping them in
  = little bit messy
    + for visible images
      + we load the thumbnail when they're given their visible/vispart class
    + for visnear images
      + we load the thumbnail in a slightly gorky part-of waitLoadedGetResolution
      + better to do it all on the class
        + if we can do it async
  = may return to this, but not now

* border missing from directories

* merging a context leaves two nearly identical event contexts on the stack
  + makes for some confusing debugging messages
    + need to decide if pushOrMerge should remove old objects from the stack
      + I think it should
    + but how do we handle its deferred
      + can't resolve
      + want to move things hanging on it over to new item
  + merge is a bit of a mess
    + we leave things hanging on the old deferred
    + not currently updating critical section
  + neater to just pull new attributes into old context
    = done that
  + however there are subtleties
    + when merging a context
      + we take over its key
    + that means that future attempts to pull by the old key will fail
      + which means new contexts get invented when they shouldn't
  + there are a few options
    + don't merge
      + just parent
        + resolving the child will kick the parent
    + merge
      + but keep all the old keys
        + key:object becomes N:1
          + not 1:N, so never multiple objects under 1 key
        + this doesn't work with our current keyarr
  + what is the essence of a merge?
    + it's only called in a fire_ type scenario
      + which is the bridge function to a handler_
    + I'm leaning towards parent
      + merge is quite destructive
        + we're losing granularity
        + parent preserves more information
          + also resolves are clearer when there's parenting
      + keep merge function the way it is
        + might be useful for other things
        + but write a new parent version and replace in fire_ family
  + not sure about auto-resolve for parents
    + they should sort of resolve themselves
      + because everything else does
    + going to take it out for now
      + might reprise it later
    + I think the only reason not to auto-resolve
      + is that the parent might need to do something first
        + if the child resolves the parent
          + that means the parent's resolved before it's completed its stuff
          = finally, everything auto-resolves
            + removed autoresolve flag
            + no necessary as also introduced eventContext.action
      + each context could have a function (func) queued
        + so that when it's ready to work
          + it can execute that function
          + then resolve itself
            + it's logical
            + up to now we've been limited to managing 'func' inside actOnContext
              + because we could be delaying it
              + that's means we've had to have the func promises in that function
                + which was messy when we tried to unify all the context resolvers
            + by putting it in a context.variable
              + we can call it anywhere
                + which allows us to move all the resolution to a single function
                  + which makes debugging and tracking easier
      + not sure about that
        + all the contexts tend to get resolved in their handlers at the moment
          + actOnContext sets a good direction of travel
        + all the wrapUp is now done in the eventQueue
          + the handler functions don't wrapUp any more
  + this is all becoming clearer
  + parenting is good

* need to bind to scroll earlier than completion of handler_hash
  + handler_hash only resolved when all nearvis loaded
    + when is the earliest we could accept scroll events
      - hard to tell
        + it's when the browser has given us the first scroll event
          + if it's going to give us it!
      + but we could rely on the critical section
        + probably safe to bind once handler_hash is in its critical section

* sfun is an image collection tool
  + for people who collect and organise images

* get eventQueue emptying out properly
  + buffered scroll events die in the queue
  + resolve can always take something out of the queue
    + fallback
  + introduce a new 3rd list to track 'unfilled' contexts
    + fill list?
      + unhandled
    + new subtle issue
      + if we match against unhandled
        + getOrInvent will now invent a new context
      + need to do a clever thing in getOrInvent
        + get matches it using the keyarr list
          + but if the corresponding entry in unhandled is null
            + that means we're already processing this event
            + and it hasn't yet been resolved
            + so don't process it again
    + unhandled array may be a chance to get rid of criticalSection?
      + maybe not
      + criticalSection covers case where an [unfired] scroll event starts processing in the middle of a hash event
  + major variable renaming
    + all local
      + apart from static, which I can live with
    + much more consistent now

* end key test not completing in proper time
  + can't actually select end entity if it's a directory
    + selection bounces back from 10 to 9

* images getting stuck in reresing
  + waiting for timeout before completing
    + suspect it's a critical section/delaying bug

* scrolling suddenly jerks back
  + then forward again after check expiries
    + set a break point on check expiries
--o--
* thinking about re-writing bufer
  + making it implicit
    + hash:seqs are queue up on the stack
      + when we've got a new one
        + there's really no value in going to the old one
        + might as well dump it
          + have to be a little bit careful of parents
            + this hash:seq could be part of a long chain
            + I think we're just going to resolve() it
              + which handles parent
                + just need to check it doesn't have children
                + which it can't because it hasn't run yet
                  + no critical_section delayed children
                  + no fired events downstream
    + this is exactly the same for the scrolls
      + we basically just want to resolve them to
        + which is what we do in buffer
  + nice to do it for everything
    + we need some mechanism of identifying similar events
      + suggest key up to first :
      + could always later come back and define families
  * actOnContext seems to be the place for vetting events
    + need to understand how we're currently delaying them
      + they seem to be getting lost because
        + they are children of refreshSelected events
          + that resolve without them [async]
        + I think we fire another fireHashUpdate so quickly
          + that the browser never processes the original hash:seq
          - no, that's not correct
        + browser does catch it
          + but we use 'replaceEvent' in place
            + which I guess nulls it and doesn't resolve it
    + idea 1: stop doing that
      + find out why we're replaceEventing and not resolving
    + idea 2: give hash:seqs an expire
      + so that checkExpiries tidies them up
  + 1 it's because in parent() we're giving children the replaceEvent
    + of their parents
      + so the parent just gets resolved
        + maybe replace replaceEvent with a flag
          + nullify
  + considering shift to resolve all contexts as part of the actOnContext
    + yes
    + change actOnContext first
      + then progressively remove the wrapUp functions
        + testing all the way
    + done
--o--
  + re-introduce buffering for [scroll] events
    + should apply to all events
      + to discard an event
        + we just remove it from the unhandled queue
        + need to be a bit careful of parents
          + they need resolving when the peer gets resolved
          + actually buffer() just resolved them instantly
            + we can do that
            + but let them hang around in 2q (not unhandled)
              + so that if a handler gets them 
                + we spin right past
    + in actOnContext
      + search list for event key root (e.g. hash: or scroll:)
        + find all events that aren't in their critical_section
  + can't do buffering until we resolve _why_ the skipping is happening
    + can't replicate that right now
      + I think shelve this for now

* work on test suite
  + need to redo eventQueue tests
    + actOnContext now resolves its own contexts

* work on test suite
  + need to check that api_keypress is really waiting until its resolved
    + properly, all the way through to completion of sub-contexts
      + as we need the hash to have completed
        + to have selected the right image
  + first 'click' event comes through jQuery
    + not sfun
      + so no mechanism to wait for done() right now
  + very close now
    + having some good complete runs

* introduce progressive scroll test
  + scroll to middle
  + check that we have > 1000px + viewport headroom
  + fire 100 x 10px scroll events in sequence
    + check that the final one gets resolved
      + check that position of browser after final event

* introduce re-res of nearvis
  + only if last_max_longest is null
    + because that's the only time we see a flash of low-res images
  + when reres is false
    + we load the low-res/thumb
  + when reres is true
    + we don't seem to load the image at all
    = seems to be solved by bracketing

* scroll lock-up
  + especially when scrolling back from high seq
    + I think we get queued up
      + then we resolve all the elements in that queue
        - simultaneously
        + which means that the processor gets slammed
          + and that stops us queuing up new events
    + can we try dumping all the events
      + instead of executing them
    + I think it's the slew of done()s
  + also got scroll events getting lost
    + and tidied up by checkExpiries
    + could be related
      + might as well tidy those up anyway
        + they all seem to be coming from fireScrollUpdate
        + directly from mouseWheeled
    + these are hard problems
    + for now
      + press on with dumping to lower load

* it's all got too complicated
  + I'm trying to track down a scroll event bug
    + let's document it here
  + start by thinking about where selected should get resolved
    + it's a context
      + so should get resolved with all the contexts
  + change out contextGetResolver to use .always()
    = done
  + move context resolver parent thing
    = everything resolved in contextAttachResolver -> resolve
  + basic load stack
      hash:seq=250
        scroll:x=23000
          scroll completes
        scroll resolved 
      hash resolved
  + basic scroll
      scroll:x=23000
        scroll completes
      scroll resolved
  + basic scroll and select next
      scroll:x=23000
        selected:seq=96
          hash:seq=96
            hash completes
          hash resolved
        selected resolved
      scroll resolved

* unhandled starts out with too many nulls
  + I would expect it to look almost exactly like keyarr
    + bear in mind that null just means its gone through actOnContext

* arrow keys not working

* end key test leads to infinite loop
  + need to nullify action
    + otherwise
    + A enters critical section
      + A fires B
        + B processes
        + B completes
        + B resolve sees A as parent
          + B's resolution calls A again
    = action = null works well

* replace unhandled with action reference instead
  + can't use action because action means it's been processed (action function called)
  + handled means that it's been through a handler_ function
    + moved handled to eventContext
    + got rid of unhandled array

* request for seq=last leads to infinite loop that breaks chrome

